<!DOCTYPE html>
<!--Author: Thomas Kubler. using examples from w3schools.com-->
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    
    <script defer src="ecescript.js"></script>
    <title>ECE 315 Examples</title>

    <!--<link href="styles.css" rel="stylesheet"> If the CSS goes overboard, the MathJax breaks-->

    <!-- MathJax for equations means the local styles has to be removed. Apache 2.0 license -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <style>
        body{
            background-color: rgb(240,240,240);
        }
        .tablink {
            background-color: rgb(70,71,117);
            color: white;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 14px;
            font-size: 17px;
            width: 20%;
        }
        .tablink:hover {
            background-color: #33F;
        }
    </style>
</head>

<body onload="InitPage()">
    <h1>ECE 315 Examples</h1>
    <button class="tablink" onclick="openBigTab('DCCircuits',this)" >DC Circuits</button>
    <button class="tablink" onclick="openBigTab('ACCircuits',this)" >AC Circuits</button>
    <button class="tablink" onclick="openBigTab('Transmission',this)">Transmission</button>
    <button class="tablink" onclick="openBigTab('Distribution',this)">Distribution</button>
    <button class="tablink" onclick="openBigTab('Efficiency',this)">Efficiency</button>
    <br>
    <button class="tablink" onclick="openBigTab('ComplexNumbers',this)">Complex Numbers</button>
    <button class="tablink" onclick="openBigTab('InductorCapacitor',this)" >Inductor Capacitor</button>
    <button class="tablink" onclick="openBigTab('AnalogFilter',this)" >Analog Filter</button>
    <button class="tablink" onclick="openBigTab('TransducerInterface',this)">Signal Conditioning</button>
    <button class="tablink" onclick="openBigTab('DataRates',this)"  >ADC Data Rates</button>
    <br>
    <button class="tablink" onclick="openBigTab('modulation',this)" id="defaultOpen">Modulation</button>
    <button class="tablink" onclick="openBigTab('commequations',this)">Communications</button>
    <button class="tablink" onclick="openBigTab('commpicture',this)">Comm Picture</button>
    <button class="tablink" onclick="openBigTab('radarequations',this)">RADAR</button>
    <button class="tablink" onclick="openBigTab('radardoppler',this)" >Doppler & Jamming</button>

    <div class="tabcontent" id="DCCircuits">
        <hr />
        <!--<img src="static/CircuitOneR.PNG" alt="One Resistor Circuit" height="300">-->
        <p>Ohm's Law says that the current through a resistor is directly proportional to the applied voltage: \[V=I\times R\]</p>
        <p>Commonly, voltage and resistance are defined and we are computing the current: \[I=\frac{V}{R}\]</p>
        Voltage: <input type="number" id="virvoltage" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectvvir" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>
        Resistance: <input type="number" id="virresistance" min="1" max="999" value="100" step="any" onchange="ChangedDC()">
        <select id="selectrvir" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <p id="virequation">eqn</p>
        <hr />
        <p>Power is the product of voltage and current: \[P=V\times I\]</p>
        Voltage: <input type="number" id="pvivoltage" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectvpvi" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>
        Current: <input type="number" id="pvicurrent" min="1" max="999" value="120" step="any" onchange="ChangedDC()">
        <select id="selectipvi" onchange="ChangedDC()">
            <option value="-9">nA</option>
            <option value="-6">&#181;A</option>
            <option value="-3" selected>mA</option>
            <option value="0">A</option>
            <option value="3">kA</option>
            <option value="6">MA</option>
        </select>
        <p id="pviequation">eqn</p>
        <hr />
        <P>The next section uses the following DC circuit and an intermediate step for showing an \(R_{EQ}\):</P>
        <img src="static/CircuitThreeR.png" alt="Three-Resistor Circuit" height="300">
        <img src="static/CircuitThreeReq.png" alt="Three-Resistor Circuit EQ" height="300"><br>
        \(R_A\)=<input type="number" id="kvlra" min="1" max="999" value="1.7" step="any" onchange="ChangedDC()">
        <select id="selectkvlra" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0">&#8486;</option>
            <option value="3" selected>k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(R_B\)=<input type="number" id="kvlrb" min="1" max="999" value="3.3" step="any" onchange="ChangedDC()">
        <select id="selectkvlrb" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0">&#8486;</option>
            <option value="3" selected>k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(R_C\)=<input type="number" id="kvlrc" min="1" max="999" value="330" step="any" onchange="ChangedDC()">
        <select id="selectkvlrc" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(V_S\)=<input type="number" id="kvlv" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectkvlv" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select><br>
        <p>Computing an equivalent resistance helps to quickly simplify circuit analysis:</p>
        <p>Resistors in parallel add conductivity together (the inverse of resistance's ohm \( \Omega \) is conductivity's mho \( \mho \)):</p>
        <p id="resistanceparallel">eqn</p>
        <p>Resistors in series add resistance together:</p>
        <p id="resistanceseries">eqn</p>
        <p>For good practice, we'll wait until the final equivalent resistance before using the term \(R_{EQ}\) as it is the value
            that the voltage source will see as a single resistor. From Ohm's Law, the source current is:</p>
        <p id="kvlohms">eqn</p>
        <p>The source current will travel through \(R_A\) and then split between parallel resistors \(R_B\) and \(R_C\) according to the current divider (be careful
            with the 2-resistor current divider equation, the resistance value in the numerator is of the *other* resistor!):
        </p>
        <p id="currentdividerb">eqn</p>
        <p id="currentdividerc">eqn</p>
        <p>Verifying the current divider by finding each device's voltage will also demonstrate how the ratio of current is inversely proportional to the resistance ratio:</p>
        <p id="currentdividerverifyb">eqn</p>
        <p id="currentdividerverifyc">eqn</p>
        <p>A voltage divider can only be applied where the resistors are in series. Only after combining \(R_B\) and \(R_C\) into \(R_{BC}\),
            as shown in the right-most diagram, are the resistors in series. The voltage divider provides a shortcut by not computing current values:
        </p>
        <p id="voltagedivider">eqn</p>
        <p>Kirchhoff's Voltage Law states that over any loop in a circuit, the net voltage change is zero:
            \[\sum^{}_{loop}\Delta V=0 \text{ or: } \sum^{}_{loop}\Delta V_{up}=\sum^{}_{loop}\Delta V_{down}\]
            From the circuit above a KVL expression \(V_S=V_A+V_B\) could be used to find \(V_A\):</p>
        <p id="kvlkvl">eqn</p>
        <p>Kirchhoff's Current Law states that for any node in a circuit, the net current flow is zero:
            \[\sum^{}_{node}I=0 \text{ or: } \sum^{}_{node}I_{in}=\sum^{}_{node}I_{out}  \]
            In the above circuit, we could use the KCL expression \(I_B+I_C=I_S\) to verify our results:
        </p>
        <p id="kclkcl">eqn</p>
    </div>

    <div class="tabcontent" id="ACCircuits">
        <hr />
        <p>The generic form of an AC voltage signal (composed of a DC bias and one cosine) is: 
            \[v_s(t)=V_{B}+V_{m}cos(360^\circ f t+\phi)V\]
            Where \(V_B\) is the Bias (or DC component). \(V_m\) is the Magnitude.
            \(\phi\) is the Phase shift. \(f\) is the Frequency and can be derived from the signal's period \(T\) by the relationship:
            \[f=\frac{1}{T}\]
            For example, the period: <input type="number" id="ACperiod" min="1" max="999" value="16.667" step="any" onchange="ChangedAC()">
            <select id="selectACperiod" onchange="ChangedAC()">
                <option value="-12">ps</option>
                <option value="-9">ns</option>
                <option value="-6">&#181;s</option>
                <option value="-3" selected >ms</option>
                <option value="0">s</option>
            </select> correlates to the frequency:
        </p>
        <p id="periodfrequency">eqn</p>
        We can start with a graph of a cosine and derive the terms \(V_B, V_m,\) and \(f\).<br>
        \(V_{Max}=\)<input type="number" id="ACVmax" min="-999" max="999" value="24" step="any" onchange="ChangedAC()">
        <select id="selectACVmax" onchange="ChangedAC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3" >mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
        </select><br>
        \(V_{Min}=\)<input type="number" id="ACVmin" min="-999" max="999" value="-12" step="any" onchange="ChangedAC()">
        <select id="selectACVmin" onchange="ChangedAC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3" >mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
        </select><br>
        \(\phi=\)<input type="number" id="ACphi" min="-360" max="360" value="90" step="any" onchange="ChangedAC()">\(^\circ\)<br>
        An \(R_{EQ}\) for power computations:
        <input type="number" id="rmsresistance" min="1" max="999" value="100" step="any" onchange="ChangedAC()">
        <select id="selectrmsr" onchange="ChangedAC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        <canvas id="ACcanvas" width="801" height="401"></canvas>
        <canvas id="ACcanvasPower" width="801" height="401"></canvas><br>
        The magnitude \(V_m\) is one-half the voltage deviation:
        <p id="vmderived">eqn</p>
        The bias \(V_B\) is the average value:
        <p id="vbderived">eqn</p>
        The AC voltage signal is:
        <p id="acveqn">eqn</p>
        The RMS-value of the AC voltage is:
        <p id="acrms">eqn</p>
        The AC current equation can be found using Ohm's law and \(v_s(t)\):
        <p id="acieqn">eqn</p>
        The RMS-value of the AC current is:
        <p id="acirms">eqn</p>
        You can use functions of time, or RMS values, with Ohm's Law, KVL, KCL, and the current and voltage dividers.
        For example, after finding \(V_{S,RMS}\), finding \(I_{S,RMS}\) from \(R_{EQ}\) is trivial:
        <p id="acohms">eqn</p>
        RMS (Root-Mean-Squared) Voltage and Current values are used to compute average power. 
        \[P_{AVE}=I_{RMS}V_{RMS}=I_{RMS}^2 R=\frac{V_{RMS}^2}{R}\]
        Average Power from the example:
        <p id="acpave">eqn</p>
        Converting \(v_s(t)\) into \(V_{S,RMS}\) (or \(i_s(t)\) into \(I_{S,RMS}\)) is a clever way of accomplishing
        the calculus as the first step and it removes the variable \(t\) as well as abstracting a complex signal into a single value.
        We'll see the steps and how the RMS equation forms. Instead of using \(360^\circ\) we'll use \(2\pi\).
        To compute an average of a periodic function, integrate that function over one cycle and then divide by its width:
        \[P_{AVE}=\frac{1}{T}\int_{0}^{T} p(t) \,dt = \frac{1}{T}\int_{0}^{T} v(t)i(t) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} [V_B+V_m cos(2\pi f t+\phi)]\times [I_B+I_m cos(2\pi f t+\phi)] \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+ V_m I_m cos^2(2\pi f t+\phi) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+ \frac{V_m I_m}{2}+\frac{V_mI_m}{2}cos(4\pi f t+2\phi) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + \frac{V_m I_m}{2} + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+\frac{V_mI_m}{2}cos(4\pi f t+2\phi) \,dt \]
        \[ =\frac{1}{T}[V_B I_B t + \frac{V_m I_m}{2}t + \frac{V_mI_B + V_BI_m}{2\pi f}sin(2\pi f t+\phi)+
            \frac{V_mI_m}{2\times4\pi f}sin(4\pi f t+2\phi)]\Big|_0^T \]
        \[ = V_BI_B+\frac{V_mI_m}{2}\]        
        <p id="acderive">eqn</p>
    </div>

    <div class="tabcontent" id="ComplexNumbers">
        <hr />
        <h4>Complex Number Formats: Rectangular, Polar, and Exponential</h4>
        Complex numbers (e.g \(2+3i\)) have a number of applications in electrical engineering (and to avoid confusion with current's \(i(t)\) we use \(j=\sqrt{-1}\)).
        If you have ever seen that \(e^{\pi i}-1=0\), then you can appreciate Euler's Formula (shown using \(j\)):
        \[e^{j\theta}=cos(\theta)+j sin(\theta)\]
        With another term \(A\) for an arbitrary magnitude, Euler's formula shows how to convert a complex number from its "Exponential" to 
        "Rectangular" (Cartesian) form. The variables are magnitude \(A\) and angle \(\theta\), and \(e\) and \(j\) are constants:
        \[Ae^{j\theta}=Acos(\theta)+j Asin(\theta)\]
        \[Real=Acos(\theta)\text{ and }Imag=Asin(\theta)\]
        <!--Why is this so useful? Recall that \(\frac{d}{dx} e^x=e^x\). When the complex number \(j\) is introduced as a constant coefficient to \(x\) it behaves like any other constant coefficient.
        In the case of \(e^x\) the derivative rotates each expression \(90^{\circ}\) around the complex plane, meaning that certain differential equations can be reduced to a geometry problem,
        and then further reduced to just Algebra.
        \[\frac{d}{dx} e^{jx}=je^{jx}\]
        \[\frac{d}{dx} je^{jx}=-e^{jx}\]
        \[-\frac{d}{dx} e^{jx}=-je^{jx}\]
        \[-\frac{d}{dx} je^{jx}=e^{jx}\]
        This same behavior is seen its rectangular form:
        \[\frac{d}{dx} [ cos(x)+j sin(x)] = -sin(x)+jcos(x)\]
        \[\frac{d}{dx} [-sin(x)+j cos(x)] = -cos(x)-jsin(x)\]
        \[\frac{d}{dx} [-cos(x)-j sin(x)] =  sin(x)-jcos(x)\]
        \[\frac{d}{dx} [ sin(x)-j cos(x)] =  cos(x)+jsin(x)\]-->
        Using the complex plane in the plot below, the positive real axis points to the right,
        and the positive imaginary axis points up. Angle \(0^{\circ}\) points to the right along the positive-real axis, and as the angle increases, the vector 
        rotates counter-clockwise through the four quadrants I, II, III and IV.
        <br>Magnitude \(A\): <input type="number" id="complexmag" min="0" max="10" value="10" step="any" onchange="ChangedComplex()">
        <br>Angle (deg) \(\theta\): <input type="number" id="complextheta" min="-360" max="360" value="30" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br><canvas id="canvasmagphase" width="250" height="250"></canvas>
        <br>To create the Rectangular form: 
        <p id="phasetorect">eqn</p>
        To create the "Polar" form, we replace the \(e^j\) with the "&#8736;" symbol (for now, it is this simple).
        <p id="phasorform">eqn</p>
        Adding complex values is most easily done with the Rectangular form. Add the terms piece-wise: Real with Real and Imaginary with Imaginary:
        \[Re_1+jIm_1+Re_2+jIm_2=Re_1+Re_2+j[Im_1+Im_2]\]
        Rectangular multiplication isn't very convenient, but it can be done (FOIL):
        \[(Re_1+jIm_1)\times(Re_2+jIm_2)=Re_1\times Re_2 - (Im_1\times Im_2)+ j(Re_1\times Im_2+Re_2\times Im_1)\]
        Rectangular division requires the use of the Complex Conjugate to rationalize the denominator and then distribute the division:
        (The Complex Conjugate of \([Re+jIm]\) is \([Re-jIm]\))
        \[\frac{Re_1+jIm_1}{Re_2+jIm_2}=\frac{(Re_1+jIm_1)}{(Re_2+jIm_2)}\times\frac{(Re_2-jIm_2)}{(Re_2-jIm_2)}=
        \frac{(Re_1\times Re_2 + Im_1\times Im_2)+ j(Re_2\times Im_1-Re_1\times Im_2)}{Re_2^2+Im_2^2}=
        \frac{Re_1\times Re_2 + Im_1\times Im_2}{Re_2^2+Im_2^2}+j\frac{Re_2\times Im_1-Re_1\times Im_2}{Re_2^2+Im_2^2}\]
        Multiplication is much easier in Exponential and Polar forms:
        \[A_1e^{j\theta_1}\times A_2e^{j\theta_2}=A_1\times A_2e^{j(\theta_1+\theta_2)}\text{  and  }\frac{A_1e^{j\theta_1}}{A_2e^{j\theta_2}}=\frac{A_1}{A_2}e^{j(\theta_1-\theta_2)}\]
        \[A_1\angle\theta_1 \times A_2\angle \theta_2=A_1\times A_2\angle \theta_1+\theta_2\ \text{  and  }\frac{A_1\angle\theta_1}{A_2\angle\theta_2}=\frac{A_1}{A_2}\angle\theta_1-\theta_2\]
        To go from "Rectangular" to "Polar" use the Pythagorean Theorem for magnitude \(A=\sqrt{Real^2+Imag^2}\) and an arctangent function to obtain the angle that satisfies
            \(tan(\theta)=\frac{Imag}{Real}\). Beware: the computation \(\theta=tan^{-1}(\frac{Imag}{Real})\)  is only correct in quadrants I and IV. Use \(atan2\) or a calculator's complex phasor 
            functionality to correctly compute angles when the complex number is in Quadrants II and III.
            If you must use \(tan^{-1}\) add \(180^{\circ}\) to the result whenever the real component is negative.
            Then, whenever \(\phi\) exceeds \(180^{\circ}\) subtract \(360^{\circ}\) (I won't show this final step -- 
            your efforts are better spent learning how to have your calculator provide phase in a single step).
        <p id="recttomagnitude">eqn</p>
        <p id="recttophase">eqn</p>
        <p id="complexfixphase">eqn</p>
        <hr />
        <h4>Phasor Transform</h4>
        Complex numbers appear in circuits when using the Phasor Transform, which removes time and frequency, leaving an expression of magnitude and phase.
        \[v_s(t)=V_m cos(360^{\circ}ft+\phi)\]
        \[Phasor\{v_s(t)\}=V_s\]
        \[V=V_m\angle\phi\]
        The transform is also reversible, but frequency has to take on its original value. And it is only valid for expressions of
        voltage or current. Assume \(f=60Hz\)
        \[I=3\angle 45^{\circ}A\]
        \[i(t)=3cos(360^{\circ}60t+45^{\circ})A\]
        Depending on the textbook, the Phasor Transform's magnitude will be the RMS-value (thus, divide by \(\sqrt{2}\) where applicable).
        You can choose whether or not to convert to RMS and back - just keep track - it is sometimes easier to remain in peak, but remember average power uses RMS.
        Thankfully, we won't do any power computations in this subject area.
        <hr />
        <h4>Phasor Addition</h4>
        So lets try to add up two voltage sources both operating at the same frequency (a must with Phasors) connected in series. Assume \(f=100Hz\)
        <br>Magnitude \(V_{m1}\): <input type="number" id="complexvm1" min="0" max="10" value="7" step="any" onchange="ChangedComplex()">V
        <br>Angle (deg) \(\phi_1\): <input type="number" id="complext1" min="-360" max="360" value="30" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br>Magnitude \(V_{m2}\): <input type="number" id="complexvm2" min="0" max="10" value="5" step="any" onchange="ChangedComplex()">V
        <br>Angle (deg) \(\phi_2\): <input type="number" id="complext2" min="-360" max="360" value="145" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br>A computer can of course perform the addition at several hundred values of \(t\) and plot the result. But we'll take advantage of the property that these two cosines are always the same
        phase apart, and that their sum will be a single cosine at this frequency, only adjusted in magnitude and phase: Phasors tolerate addition. If they are close in phase, they are constructive. If they are 
        far apart in phase, they are destructive. Instead of using geometry, we'll convert functions into their Phasors and then perform addition, before returning to the time-domain:
        <p id="complexaddend1">eqn</p>
        <p id="complexaddend2">eqn</p>
        <p id="complexaddition">eqn</p>
        <p id="complexresult">eqn</p>
        <canvas id="canvasaddvoltage" width="1000" height="250"></canvas> 
        <br><canvas id="canvasaddvectors" width="250" height="250"></canvas>
        <br><button onclick="animatecomplex()">Animate</button><button onclick="stopanimatecomplex(false)">Stop</button><button onclick="stopanimatecomplex(true)">Reset</button>
        <br>A Voltage (or Current) Phasor is not itself a time-based value, but if we rotate the Phasors about the origin, then the Real components of the Complex Phasors
        represent the value that would be seen on the graph of \(v(t)\) just above. The animation demonstrates that because the two voltage sources operate at the same
        frequency, their Phasor sum will also "rotate" at that frequency. In fact, for any number of sinusoids (not just two) of the same frequency, their sum will be a single
        sinusoid at that frequency.
        <hr />
        <h4>Phasor Multiplication</h4>
        Word of warning: we do <strong>not</strong> multiply two voltage phasors together, nor two current, nor a voltage and a current. Why? Linearity.
        When we multiply our function by a <strong>constant</strong> the calculus is unaffected:
        \[ \int 2cos(x) \,dx = 2\int cos(x) \,dx\]
        \[\frac{d}{dx}4cos(x)=4\frac{d}{dx}cos(x)\]
        However, if we attempt to take the product of two functions, the calculus can be wildly different.
        For trigonmetric functions, the frequencies will also change.
        \[\frac{d}{dx}[cos(x)]=-sin(x)\]
        \[\frac{d}{dx}[cos(x)\times cos(x)]=-2sin(x)\times cos(x)=-sin(2x)\]
        The multiplication we can do is of the form \(V=I Z\) where \(Z\) is the Impedance of a Resistor, Capacitor, or Inductor.
    </div>

    <div class="tabcontent" id="InductorCapacitor">
        <p>Our passive circuit components are the resistor (R), inductor (L), and capacitor (C). Using the same form as Ohm's Law, we introduce 
            the concept of impedance which quantifies the relationship between \(V\) and \(I\) in the term \(Z\), a complex number.
        </p>
        \[\text{Resistor: }v_R(t)=i(t)R\rightarrow Z_R=R\]
        \[\text{Inductor: }v_L(t)=L\frac{di}{dt}\rightarrow Z_L=j\omega L\]
        \[\text{Capacitor: }i_C(t)=C\frac{dv}{dt}\rightarrow Z_C=\frac{1}{j\omega C}\]
        \[\text{where: }\omega=2\pi f\]
        Let's see what kind of impedance values that typical inductors and capacitors take on with different frequencies:
        <br>Frequency: <input type="number" id="ICfreq" min="1" max="999" value="60" step="any" onchange="ChangedIC()">
        <select id="ICfreqexp" onchange="ChangedIC()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Resistance: <input type="number" id="ICresistance" min="1" max="999" value="50" step="any" onchange="ChangedIC()">
        <select id="ICresistanceP" onchange="ChangedIC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <br>Inductance: <input type="number" id="inductorvalue" min="1" max="999" value="142" step="any" onchange="ChangedIC()">
        <select id="inductorvalueexp" onchange="ChangedIC()">
            <option value="-6">&#181;H</option>
            <option value="-3" selected>mH</option>
            <option value="0">H</option>
        </select>
        <br>Capacitance: <input type="number" id="capacitancevalue" min="1" max="999" value="160" step="any" onchange="ChangedIC()">
        <select id="capacitancevalueexp" onchange="ChangedIC()">
            <option value="-12">pF</option>
            <option value="-9" >nF</option>
            <option value="-6"selected>&#181;F</option>
            <option value="-3" >mF</option>
            <option value="0">F</option>
        </select>
        <p id="ICrexp">eqn</p>
        <p id="inductorimpedance">eqn</p>
        <p id="capacitorimpedance">eqn</p>
        <p>Let's build a circuit using your values and plot \(v_s(t)\) and \(i_s(t)\). Choose a topology:
            <select id="topology" onchange="ChangedIC()">
                <option value="SRLC" selected >Series RLC</option>
                <option value="SRC">Series RC</option>
                <option value="SRL">Series RL</option>
                <option value="SLC">Series LC</option>
                <option value="PRLC">Parallel RLC</option>
                <option value="PRC">Parallel RC</option>
                <option value="PRL">Parallel RL</option>
                <option value="PLC">Parallel LC</option>
            </select>
        </p>
        <p id="ICzeq">Zeq eqn</p>
        <p id="ICvoltageeqn">Veqn</p>
        <p id="ICcurrenteqn">Ieqn</p>
        Current per grid square <select id="currentzoom" onchange="ChangedIC()">
            <option value=5>100 kA</option>
            <option value=4>10 kA</option>
            <option value=3>1 kA</option>
            <option value=2>100 A</option>
            <option value=1>10 A</option>
            <option value=0>1 A</option>
            <option value=-1 selected>100 mA</option>
            <option value=-2>10 mA</option>
            <option value=-3>1 mA</option>
            <option value=-4>100 &#181;A</option>
        </select>
        Time per grid square <select id="timezoom" onchange="ChangedIC()">
            <option value=-12>1 ps</option>
            <option value=-11>10 ps</option>
            <option value=-10>100 ps</option>
            <option value=-9>1 ns</option>
            <option value=-8>10 ns</option>
            <option value=-7>100 ns</option>
            <option value=-6>1 &#181;s</option>
            <option value=-5>10 &#181;s</option>
            <option value=-4>100 &#181;s</option>
            <option value=-3 selected>1 ms</option>
            <option value=-2>10 ms</option>
            <option value=-1>100 ms</option>
            <option value=0>1 s</option>
        </select>
        <label for="accept">
            <input type="checkbox" id="autoscaleIC" name="accept" value="yes" checked onchange="ChangedIC()">  Auto Scale 
         </label><br>    
        <canvas id="canvasICplot" width="1000" height="250"></canvas> 
    </div>

    <div class="tabcontent" id="AnalogFilter">
        <p>Combinations of Resistors, Capacitors, and Inductors can be used as filters based upon their frequency response. We will consider
            the source to the input, and one of the components will be the output. Thus the filter's behavior at any single frequency can be
            computed using a ratio of the output voltage to the input voltage as such:
        </p>
        \[Gain=\frac{V_o}{V_i}\]
        <!--
        <p>Typically, \(Gain\) can be computed by creating a voltage divider. For example, an RC filter will have \(Gain\):</p>
        \[Gain=\frac{Z_C}{Z_R+Z_C}=\frac{\frac{1}{j\omega C}}{R+\frac{1}{j\omega C}}
            =\frac{\frac{1}{j\omega C}}{R+\frac{1}{j\omega C}}\times\frac{j\omega C}{j\omega C} =\frac{1}{1+j\omega RC}\]
        \[\frac{1}{1+j\omega RC}=\frac{1\angle 0}{\sqrt{1^2+\omega^2 R^2 C^2}\angle tan^{-1}(\frac{\omega R C}{1})}
            =\frac{1}{\sqrt{1+\omega^2R^2C^2}}\angle -tan^{-1}(\frac{\omega R C}{1})=\frac{1}{\sqrt{1+\omega^2R^2C^2}}\angle tan^{-1}(-\omega R C)\]
        <p>We know that the second device in the name RC is "C" so the capacitor will be the output component. This is because its ground
            terminal will be shared with the input's ground terminal, which follows the rule of maintaining a common ground. It is not always 
            necessary, but a common ground should be used whenever possible.
            <br>For series filters (RC, CR, LR, RL), the steps to creating this expression for gain (seen above) are as follows:
            <br>1. Create the ratio of impedances in the form \(Gain=\frac{Z_{2}}{Z_1+Z_2}\)
            <br>2. Multiply through by the reciprocal of \(Z_2\) because it appears twice in the expression.
                Result is now \(Gain=\frac{1}{\frac{Z_1}{Z_2}+1}\)
            <br>3. Change the numerator into its Polar form: \(1\angle 0\).
            <br>4. Change the denominator into its Polar form: \(\sqrt{1+[Imag]^2}\angle tan^{-1}({Imag})\)
            <br>5. The resultant quotient is: \(\frac{1}{\sqrt{1+[Imag]^2}}\angle tan^{-1}(-[Imag])\) where \([Imag]\) is the 
            imaginary component of \(1+\frac{Z_1}{Z_2}\). Its Real component is just \(1\) and is thus omitted from \(tan^{-1}\).
        </p>-->
        <br>Frequency: <input type="number" id="FilterFreq0" min="1" max="999" value="300" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq0P" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Resistance: <input type="number" id="FilterR" min="1" max="999" value="10" step="any" onchange="ChangedFilter()">
        <select id="FilterRP" onchange="ChangedFilter()">
            <option value="-3">m&#8486;</option>
            <option value="0"selected >&#8486;</option>
            <option value="3" >k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <br>Inductance: <input type="number" id="FilterL" min="1" max="999" value="200" step="any" onchange="ChangedFilter()">
        <select id="FilterLP" onchange="ChangedFilter()">
            <option value="-6">&#181;H</option>
            <option value="-3" selected>mH</option>
            <option value="0">H</option>
        </select>
        <br>Capacitance: <input type="number" id="FilterC" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="FilterCP" onchange="ChangedFilter()">
            <option value="-12">pF</option>
            <option value="-9" >nF</option>
            <option value="-6"selected>&#181;F</option>
            <option value="-3" >mF</option>
            <option value="0">F</option>
        </select>
        <br>Choose a topology and we'll create expressions for Gain:
            <select id="Filtertopology" onchange="ChangedFilter()">
                <option value="SRLC" selected >Series RLC</option>
                <option value="SRC" >Series RC</option>
                <option value="SCR">Series CR</option>
                <option value="SRL" >Series RL</option>
                <option value="SLR" >Series LR</option>
                <option value="SLC">Series LC</option>
                <option value="SCL">Series CL</option>
            </select>
        <p id="FilterGain">FilterGain</p>
        <p id="FilterGainFinish">FilterGainFinish</p>
        And plot this Gain over a range of frequencies (both axes on logarithmic scale):
        <br>Start Frequency: <input type="number" id="FilterFreq1" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq1P" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Stop Frequency: <input type="number" id="FilterFreq2" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq2P" onchange="ChangedFilter()">
            <option value="0" >Hz</option>
            <option value="3" >kHz</option>
            <option value="6"selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Max Gain: <select id="BodeMaxP" onchange="ChangedFilter()">
            <option value="3">1000.0</option>
            <option value="2">100.0</option>
            <option value="1" selected>10.</option>
            <option value="0">1.0</option>
        </select>
        <br>Min Gain: <select id="BodeMinP" onchange="ChangedFilter()">
            <option value="-3" >0.001</option>
            <option value="-6" >0.000001</option>
            <option value="-9" selected>0.000000001</option>
            <option value="-12">0.000000000001</option>
            <option value="-15">0.000000000000001</option>
        </select>
        <br>Click on the chart to display detailed information.
        <br><canvas id="canvasBODE" width="1200" height="500" onclick="LabelFrequencyResponse(event)"></canvas> 
        <br><button id="BodeLeftDec" onclick="BodeSlew(-10)">Decade Left</button>
        <button id="BodeLeft" onclick="BodeSlew(-1)">Step Left</button>
        <button id="BodeRight" onclick="BodeSlew(1)">Step Right</button>
        <button id="BodeRightDec" onclick="BodeSlew(10)">Decade Right</button>
        <hr />
        Time Window: <input type="number" id="timewindow" min="1" max="999" value="10" step="any" onchange="ChangedFilter()">
        <select id="timewindowp" onchange="ChangedFilter()">
            <option value=-15>fs</option>
            <option value=-12>ps</option>
            <option value=-9>ns</option>
            <option value=-6>&#181;s</option>
            <option value=-3 selected>ms</option>
            <option value=0>s</option>
        </select>
        <input type="checkbox" id="checktimewindow" onchange="ChangedFilter()" checked><label for="checktimewindow">Auto Scale Time</label>
        <br>Voltage Window: <input type="number" id="vwindow" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="vwindowp" onchange="ChangedFilter()">
            <option value=-15>fV</option>
            <option value=-12>pV</option>
            <option value=-9>nV</option>
            <option value=-6>&#181;V</option>
            <option value=-3 >mV</option>
            <option value=0 selected>V</option>
            <option value=3>kV</option>
        </select>
        <input type="checkbox" id="checkvoltagewindow" onchange="ChangedFilter()" checked><label for="checkvoltagewindow">Auto Scale Voltage</label>
        <br><canvas id="canvasFilterTime" width="1200" height="500" onclick="LabelFilterTime(event)"></canvas> 
        <br>Input: Construct a signal on your own or add a bunch of components and hit the "Square Wave." Then hit "Update System"<br>
        <button onclick="CleanUpComponents()">Reset to 1 Component</button>
        <button onclick="AddFilterComponent()">Add Signal Component</button>
        <button onclick="AutoSquareFilter()">Square Wave</button>
        <button onclick="ChangedFilter()">Update System</button>
        <button onclick="PlayFilterInput()">Input Sound</button>
        <button onclick="PlayFilterOutput()">Output Sound</button> Sounds are normalized for volume and this page will round all frequencies 
        to the nearest whole number frequency so that all components are a harmonic of 1 Hz. If you have a modern browser, 
        then the waveforms can be heard for 2 seconds with these buttons.
        Speakers will accentuate certain frequencies and filtering HF may not seem apparent. Frequencies above 10kHz and below 50 Hz are not included for your safety.
        <br>Bias (V): <input type="number" id="filterbias" min="-999" max="999" value="0" step="any" onchange="ChangedFilter()">
            <select id="filterbiasp" onchange="ChangedFilter()">
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3"selected >mV</option>
                <option value="0" >V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select><br>
        <div id="inputpart1" class="addablepart">
            Voltage: <input class="filtervoltage" type="number" id="filtersig0" min="-999" max="999" value="1" step="any" onchange="ChangedFilter()">
            <select class="filtervoltagep" id="filtersig0p" onchange="ChangedFilter()">
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3">mV</option>
                <option value="0" selected>V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select>
            Frequency: <input class="filterfreq" type="number" id="filtersigf0" min="1" max="999" value="300" step="any" onchange="ChangedFilter()">
            <select class="filterfreqp" id="filtersigf0p" onchange="ChangedFilter()">
                <option value="0"selected >Hz</option>
                <option value="3">kHz</option>
                <option value="6" >MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select>
            Phase \(\phi\): <input type="number" class="filterphi" id="filtersigphi" min="-360" max="360" value="0" step="any" onchange="ChangedFilter()"> \(^{\circ}\)
        </div>
        <br>Output (as determined by the magnitude and phase response of the above chosen R, L, C and topology): 
        <br>Bias (V): <input type="number" id="outputbias" min="-999" max="999" value="100" step="any" disabled>
            <select id="outputbiasp" disabled>
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3"selected >mV</option>
                <option value="0" >V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select><br>
        <div id="outputpart1" class="outputadd">
            Voltage: <input class="outv" type="number" id="outv0" min="-999" max="999" value="800" step="any" disabled>
            <select class="outvp" id="outv0p" disabled>
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3"selected>mV</option>
                <option value="0" >V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select>
            Frequency: <input class="outf" type="number" id="outf0" min="1" max="999" value="100" step="any" disabled>
            <select class="outfp" id="outf0p" disabled>
                <option value="0"selected >Hz</option>
                <option value="3">kHz</option>
                <option value="6" >MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select>
            Phase \(\phi\): <input type="number" class="outphi" id="outphi0" min="-360" max="360" value="0" step="any" disabled> \(^{\circ}\)
        </div>
        
        <br><canvas id="canvasFilterSpectrum" width="1200" height="500" onclick="LabelFilterSpectrum(event)"></canvas> 
    </div>

    <div class="tabcontent" id="TransducerInterface">
        Design and Inspect a Transducer Interface and ADC/DAC. For those who care: frequencies are constrained to the range of 0..\(\frac{1}{2}f_s\)
         due to the use of a DFT to model the DAC's output filtering. 
        <br>Enter sensor and ADC voltage ranges and we'll find \(K\) and \(B\) to generate a XDCR interface. (Sensor voltages can be increasing or
        decreasing, so it is not called \(Min\) & \(Max\)):
        <br>Sensor Voltage A: <input type="number" id="sensora" min="-999" max="999" value="-20" step="any" onchange="ChangedTransducer()">
        <select id="sensorap" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0" >V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        ADC Voltage A: <input type="number" id="adca" min="-999" max="999" value="0" step="any" onchange="ChangedTransducer()">
        <select id="adcap" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>Sensor Voltage B: <input type="number" id="sensorb" min="-999" max="999" value="20" step="any" onchange="ChangedTransducer()">
        <select id="sensorbp" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0">V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        ADC Voltage B: <input type="number" id="adcb" min="-999" max="999" value="5" step="any" onchange="ChangedTransducer()">
        <select id="adcbp" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <p id="Keqn">Compute K</p>
        <p id="Beqn">Compute B</p>
        Test the interface with a specific voltage \(V_{In}\): <input type="number" id="testvoltage" min="-999" max="999" value="11" step="any" onchange="ChangedTransducer()">
        <select id="testvoltagep" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0" >V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <p id="Vout">Compute Vout</p>
        <p id="clippingmessage"></p>
        Finish designing the ADC by defining \(b\): <input type="number" id="bitsize" min="1" max="128" value="8" step="1" onchange="ChangedTransducer()">
        <p id="deltaV">Compute DV</p>
        <p id="evallevel">Compute ELandQL</p>
        <p id="quantizationerror">Compute QE</p>
        Now let's specify a sensor as a function of time and watch how it is sampled, quantized, encoded, and then recreated over a 1-second
        time period. The vertical range of each graph is determined by the transducer interface design from above.
        <br><button onclick="AddSignalFreq()">Add Signal Component</button>
        <button onclick="AutoSquare()">Square Wave</button>
        <button onclick="ChangedTransducer()">Update Graph</button>
        <button onclick="PlayADCInputSound()" disabled>Listen To Me (I'm really loud!)</button><br>
        Bias (V): <input type="number" id="adcsignalvb" min="-999" max="999" value="0" step="any" onchange="ChangedTransducer()">
            <select id="adcsignalvbp" onchange="ChangedTransducer()">
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3"selected >mV</option>
                <option value="0" >V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select><br>
        <div id="signalcomponent1" class="addablesignal">
            Voltage: <input class="adcsignalv" type="number" id="adcsignalv0" min="-999" max="999" value="10" step="any" onchange="ChangedTransducer()">
            <select class="adcsignalvp" id="adcsignalv0p" onchange="ChangedTransducer()">
                <option value="-9">nV</option>
                <option value="-6" >&#181;V</option>
                <option value="-3"selected>mV</option>
                <option value="0" >V</option>
                <option value="3">kV</option>
                <option value="6">MV</option>
            </select>
            Frequency: <input type="number" class="adcsignalf" id="adcsignalf0" min="1" max="999" value="25" step="any" onchange="ChangedTransducer()">
            <select class="adcsignalfp" id="adcsignalfp0" onchange="ChangedTransducer()">
                <option value="0"selected >Hz</option>
                <option value="3">kHz</option>
                <option value="6" >MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select>
            Phase \(\phi\): <input type="number" class="adcsignalphi" id="adcsignalphi0" min="-360" max="360" value="0" step="any" onchange="ChangedTransducer()"> \(^{\circ}\)
        </div>
        <button onclick="HideCanvasX()" id="buttonHideX">Show/Hide Sensor</button>
        <br><canvas id="canvasXDCRtime" width="1200" height="400" onclick="LabelXDCRTime(event)"></canvas>
        <br>ADC Sampling Rate: 
        <input type="number" class="adcsample" id="adcsamplerate" min="1" max="999" value="49" step="any" onchange="ChangedTransducer()">
        <select id="adcsamplefp" onchange="ChangedTransducer()">
            <option value="0"selected>Hz</option>
            <option value="3">kHz</option>
            <option value="6" >MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>The Digital Processing step is limited to <a id="numsamples"></a> samples. If the sample rate is too high,
        only a portion of the input will be seen and the output will be distorted.<br>
        <input type="checkbox" id="ShowADCIn" onchange="ChangedTransducer()" checked><label for="ShowADCIn">Input Signal</label>
        <input type="checkbox" id="ShowDigitized" onchange="ChangedTransducer()" checked><label for="ShowDigitized">Quantized</label>
        <input type="checkbox" id="ShowBlockStyle" onchange="ChangedTransducer()" ><label for="ShowBlockStyle">Block Style</label>
        <input type="checkbox" id="ShowDACOut" onchange="ChangedTransducer()" ><label for="ShowDACOut">Digitally Processed</label>
        <br><input type="checkbox" id="AutoHPF" onchange="ChangedTransducer()" checked><label for="AutoHPF">Auto DAC HPF \(F_{co}\):</label>
        <input type="number" id="dachfco" min="1" max="999" value="1" step="any" onchange="ChangedTransducer()">
                <select id="dachfcop" onchange="ChangedTransducer()">
                    <option value="0"selected >Hz</option>
                    <option value="3">kHz</option>
                    <option value="6" >MHz</option>
                    <option value="9">GHz</option>
                    <option value="12">THz</option>
                </select>
        <input type="checkbox" id="AutoLPF" onchange="ChangedTransducer()" checked><label for="AutoLPF">Auto DAC LPF \(F_{co}\):</label>
        <input type="number" id="dacfco" min="1" max="999" value="10" step="any" onchange="ChangedTransducer()">
            <select id="dacfcop" onchange="ChangedTransducer()">
                <option value="0"selected >Hz</option>
                <option value="3">kHz</option>
                <option value="6" >MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select> If \(f_{co}\nleq \frac{1}{2}f_{s}\) then the entry is ignored. This page only models frequencies up to \(\frac{1}{2}f_s\)
        <br><button onclick="HideCanvasA()" id="buttonHideX">Show/Hide ADC</button>
        <br><canvas id="canvasADCtime" width="1200" height="400" onclick="LabelADCTime(event)"></canvas>
        <br><button onclick="HideCanvasS()" id="buttonHideX">Show/Hide Spectrum</button>
        <br><canvas id="canvasADCSpectrum" width="1200" height="200" onclick="LabelADCSpectrum(event)"></canvas>
        <br><button onclick="HideCanvasD()" id="buttonHideX">Show/Hide DAC</button>
        <br><canvas id="canvasDACtime" width="1200" height="400" onclick="LabelDACTime(event)"></canvas>
        <hr />
    </div>

    <div class="tabcontent" id="DataRates">
        You will need to be familiar with relating data rates, time, and memory usage. We will start with an ADC:
        <br>\(b\) per sample: <input type="number" id="DRbitsize" min="1" max="1024" value="16" step="1" onchange="ChangedDR()">
        <br><br>An ADC encodes its values from \(0..2^b-1\) in binary form. Each sample, regardless of value,
        results in the same number of bits. For example:
        <br>Decimal value: <input type="number" id="DRdecimal" min="0" value="1" step="1" onchange="ChangedDR()">
        <p id="eqnDRbinary">binary</p>
        An ADC's bit rate is the product of its sample rate and its sample size. 
        <br>ADC Sample Frequency: 
        <input type="number" id="DRsamplerate" min="1" max="999" value="88.2" step="any" onchange="ChangedDR()">
        <select id="DRsampleratep" onchange="ChangedDR()">
            <option value="0">Hz</option>
            <option value="3"selected>kHz</option>
            <option value="6" >MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <p id="eqnbitrate">bitrate</p>
        It should be emphasized that the prefixes for magnitude (such as \(k\), \(M\), or \(G\)) in the context of 
        bit rates are their powers of 10 (that is, \(10^3\), \(10^6\), \(10^9\)). This is \(not\) true for memory sizes.
        Memory size prefixes will be powers of 2 as in:\[1KB = 2^{10}B\] \[1MB = 2^{20}B\] \[1GB=2^{30}B\] \[1TB=2^{40}B\]
        You might also notice \(KB\) uses a capitalized \(K\). 
        <p>The following expression will guide how to arrange solutions to memory size questions:</p>
        \[Data Rate=\frac{Memory}{Time}\]
        For example, let's solve for \(Time\) given the previous bit rate and the following memory size:
        <br>Memory Size:<input type="number" id="DRmemory" min="1" max="999" value="700" step="any" onchange="ChangedDR()">
        <select id="DRmemoryp" onchange="ChangedDR()">
            <option value=0>B</option>
            <option value=10 >kB</option>
            <option value=20 selected>MB</option>
            <option value=30>GB</option>
            <option value=40>TB</option>
        </select>
        <p id="DRsolveT">solve for T</p>
        If the result is large enough, convert to minutes or even seconds. It is fine to use decimal minutes (as opposed to the English MM:SS).
        <p id="DRsolveTsecond"></p>
        <hr />
        Another example (Solve for bit rate):
        <br>Memory Size:<input type="number" id="DRmemory2" min="1" max="999" value="1" step="any" onchange="ChangedDR()">
        <select id="DRmemory2p" onchange="ChangedDR()">
            <option value=0>B</option>
            <option value=10 >kB</option>
            <option value=20>MB</option>
            <option value=30 selected>GB</option>
            <option value=40>TB</option>
        </select>
        <br>Time: <input type="number" id="DRtime" min="1" max="60" value="30" step="any" onchange="ChangedDR()">
        <select id="DRtimeM" onchange="ChangedDR()">
            <option value="s">s</option>
            <option value="min" selected>min</option>
            <option value="hr">hr</option>
            <option value="day">day</option>
            <option value="year">year</option>
        </select>
        <p id="DRsolveBR">solve for bit rate</p>
        <hr />
        Lastly, solve for a memory size:
        <br>Bit Rate:<input type="number" id="DRrate3" min="1" max="999" value="128" step="any" onchange="ChangedDR()">
        <select id="DRrate3p" onchange="ChangedDR()">
            <option value=0>bps</option>
            <option value=3 selected>kbps</option>
            <option value=6>Mbps</option>
            <option value=9 >Gbps</option>
            <option value=12>Tbps</option>
        </select>
        <br>Time: <input type="number" id="DRtime3" min="1" max="60" value="3.5" step="any" onchange="ChangedDR()">
        <select id="DRtimeM3" onchange="ChangedDR()">
            <option value="s">s</option>
            <option value="min" selected>min</option>
            <option value="hr">hr</option>
        </select>
        <p id="DRsolveMem">solve for memory</p>
        <hr />
    </div>

    <div class="tabcontent" id="modulation">
        <strong>Amplitude Modulation:</strong><br>
        A generic "carrier" signal composed of a single cosine of amplitude \(A_c\) operating at frequency \(f_c\) with 
        phase delay \(\phi_c\):
        \[v_c(t)=A_c cos(360^{\circ}f_c t+\phi_c)\]
        And a generic "message" signal composed of a single frequency and a DC bias \(B\):
        \[v_m(t)=B+A_m cos(360^{\circ}f_m t+\phi_m)\]
        If we multiply \(v_c(t)\) by our message function \(v_m(t)\), we would be effectively modulating the amplitude of the carrier:
        The modulated waveform will be: \(v_{am}(t)\)
        \[v_{am}=v_m(t) v_c(t)=[B+A_m cos(360^{\circ}f_m t)]A_c cos(360^{\circ}f_c t)
            =BA_c cos(360^{\circ}f_c t)+A_mA_c cos(360^{\circ}f_m t)cos(360^{\circ}f_c t)\]
        For reasons of mathematical simplicity, we've removed the phase terms \(\phi_m\) and \(\phi_c\) under the 
        assumption that \(\phi_m=0\) and \(\phi_c=0\).
        <br>The second term is not fundamentally a single frequency: it is the product of two dissimilar cosines. So what frequency is it?
        <br><br><strong>Product Identity</strong><br>
        \[cos(\alpha) cos(\beta) = \frac{1}{2}cos(\alpha+\beta)+\frac{1}{2}cos(\alpha-\beta) \]
        Apply this identity to \(v_{am}(t)\):
        \[v_{am}=BA_c cos(360^{\circ}f_c t)+\frac{1}{2}A_cA_m\times cos(360^{\circ}(f_c+f_m) t)+\frac{1}{2}A_cA_m\times cos(360^{\circ}(f_c-f_m) t)\]
        <br><strong>Modulation Index</strong> describes modulation behavior based on the relative magnitude of \(B\) and \(A_m\).
        \[\alpha=\frac{A_m}{B}\]
        Over-modulated: When \(\alpha>1\), \(A_m>B\), and the carrier is modulated to a negative amplitude. However, a negative amplitude to a cosine is 
        also just a 180-degree phase shift, which complicates demodulation.
        <br>100%-modulated: When \(\alpha=1\), \(A_m=B\), the message will reach \(0V\) and the upper envelope will kiss (barely touch) the lower envelope.
        <br>Under-modulated: When \(\alpha< 1\), \(A_m< B\), the message (seen in green) remains above \(0V\) and the carrier always 
        takes on a positive amplitude. The upper envelope (edge) of the carrier approximates the message.
        <p>Here are modulation index \(\alpha\) and modulation efficiency \(\eta\) for the following example system:</p>
        <p id="qalpha"></p>
        <p id="qeta"></p>
        <br>Let's see it in action in time and then frequency domains:
        <br>Carrier Frequency \(f_c\):
        <input type="number" id="carrierf" min="1" max="999" value="100" step="any" onchange="ChangedModulation()">
        <select id="carrierfp" onchange="ChangedModulation()">
            <option value="0">Hz</option>
            <option value="3"selected>kHz</option>
            <option value="6" >MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Carrier Amplitude \(A_c\): <input type="number" id="carrierv" min="1" max="999" value="1" step="any" onchange="ChangedModulation()">
        <select id="carriervp" onchange="ChangedModulation()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>Synchronous Demodulation Frequency \(f_x\):
        <input type="number" id="demodf" min="1" max="999" value="100" step="any" onchange="ChangedModulation()">
        <select id="demodfp" onchange="ChangedModulation()">
            <option value="0">Hz</option>
            <option value="3"selected>kHz</option>
            <option value="6" >MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br><br>Message Bias \(B\): <input type="number" id="messageb" min="0" max="999" value="1" step="any" onchange="ChangedModulation()">
        <select id="messagebp" onchange="ChangedModulation()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <button onclick="AddMessageComponent()">Add Message Frequency</button>
        <button onclick="RandomizeMessages()">Randomize Message Components</button>
        <button onclick="CleanUpMessages()">Remove All Additional Components</button>
        <div class = "messagecomponent">
        Frequency \(f_m\):
        <input type="number" id="messagef" class = "msgfreqs" min="1" max="999" value="2" step="any" onchange="ChangedModulation()">
        <select id="messagefp" class = "msgfreqPs" onchange="ChangedModulation()">
            <option value="0">Hz</option>
            <option value="3"selected>kHz</option>
            <option value="6" >MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Amplitude \(A_m\) : <input type="number" class = "msgamps" id="messagev" min="-999" max="999" value="500" step="any" onchange="ChangedModulation()">
        <select id="messagevp" class = "msgampPs" onchange="ChangedModulation()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0" >V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        Phase: <input type="number" class="msgphis" id="msgphi0" min="0" max="360" value="45" step="any" onchange="ChangedModulation()">
        </div>
        <br><input type="checkbox" id="modtimemsg" onchange="UpdateModulationView()" checked><label for="modtimemsg">Message with Bias</label>
            <input type="checkbox" id="modtimeam" onchange="UpdateModulationView()" checked><label for="modtimeam">Amplitude Modulated</label>
            <input type="checkbox" id="modtimerectified" onchange="UpdateModulationView()" checked><label for="modtimerectified">Rectified</label>
            <input type="checkbox" id="modtimesmooth" onchange="UpdateModulationView()" checked><label for="modtimesmooth">Smoothed (LPF \(f_{co}>Max(f_m)\))</label>
            <input type="checkbox" id="modtimedebiased" onchange="UpdateModulationView()" checked><label for="modtimedebiased">Bias-Removed (HPF \(f_{co}< Min(f_m)\))</label>
            <br>Analysis Sample Size: <input type="number" id="modsamplesize" min="100" max="10000" value="1000" step="100" onchange="ChangedModulation()">
            Time Window:
            <input type="number" id="modtimewindow" min="1" max="999" value="1" step="any" onchange="ChangedModulation()">
            <select id="modtimewindowp" onchange="ChangedModulation()">
                <option value="-9">ns</option>
                <option value="-6">&#181;s</option>
                <option value="-3"selected >ms</option>
                <option value="0">s</option>
            </select>
        <br><canvas id="canvasMODtime" width="1200" height="400"></canvas>
        <br>Spectrum Overlays:<input type="checkbox" id="modshowmsg" onchange="UpdateModulationView()" checked><label for="modshowmsg">Show Original Message</label>
            <input type="checkbox" id="modshowam" onchange="UpdateModulationView()" checked><label for="modshowam">Show AM Signal</label>
            <input type="checkbox" id="modshowdemod" onchange="UpdateModulationView()" checked><label for="modshowdemod">Show Synch-Demodulated Signal</label>
            <input type="checkbox" id="modshowdemodenv" onchange="UpdateModulationView()" checked><label for="modshowdemodenv">Show Envelope-Demodulated Signal</label>
        <br>View Window: 
            <input type="radio" class="modview" id="modwayleft" onchange="SetModSpectrum('wayleft')" ><label for="modwayleft">0..fm</label>
            <input type="radio" class="modview" id="modleft" onchange="SetModSpectrum('left')" ><label for="modleft">0..fc+fm</label>
            <input type="radio" class="modview" id="modfocus" onchange="SetModSpectrum('center')"><label for="modfocus">fc-fm..fc+fm</label>
            <input type="radio" class="modview" id="modright" onchange="SetModSpectrum('right')"><label for="modright">2*fc-fm..2*fc+fm</label>
            <input type="radio" class="modview" id="modfull" onchange="SetModSpectrum('full')" checked><label for="modfull">0..2*fc+fm</label>
        <br><canvas id="canvasMODspect" width="1200" height="400"></canvas>
    </div>

    <div class="tabcontent" id="commequations">
        <hr />
        <p>The wavelength of a radio transmission can be computed using the speed of light \(c\) and the radio frequency \(f\):</p>
        <a>Frequency: </a>
        <input type="number" id="commfreqarg" min="1" max="999" value="300" step="any" onchange="ChangedComm()">
        <select id="commfreqexp" onchange="ChangedComm()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6" selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <p id="lambdaeqn">eqn</p>
        <hr />
        <p>The gain \(G\) of a parabolic dish antenna of radius \(r\), efficiency \(\eta\), and wavelength \(\lambda\):
            \[G={(2\pi r)^2\over \lambda^2}\eta\]</p>
        <p>The monopole antenna achieves an ideal gain \(G=3.24\) at it's ideal length, one-quarter wavelength: \(L={\lambda \over 4}\) </p>
        <p>The dipole antenna achieves an ideal gain \(G=1.64\) at it's ideal length, one-half wavelength: \(L={\lambda \over 2}\)</p>
        <a>Transmitter:</a>
        <select id="transmittertype" onchange="ChangedComm()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3">Parabolic</option>
            <option value="4"selected>Unspecified</option>
        </select><br>
        <a id="txlengthtext">Radius (not diameter): </a>
        <input type="number" id="txantennalength" min="1" max="999" value="1" step="any" onchange="ChangedComm()">
        <select id="txantennaexp" onchange="ChangedComm()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="txetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="txdisheta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedComm()">
        <br>
        <a>Gain:</a><input disabled type="number" id="txgain" value="2" step="any" onchange="ChangedComm()">
        <br><br>
        <a>Receiver:</a>
        <select id="receivertype" onchange="ChangedComm()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="rxlengthtext">Radius (not diameter): </a>
        <input type="number" id="rxantennalength" min="1" max="999" value="1" step="any" onchange="ChangedComm()">
        <select id="rxantennaexp" onchange="ChangedComm()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="rxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="rxdisheta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedComm()">
        <br>
        <a>Gain:</a><input disabled type="number" id="rxgain" value="1" step="any" onchange="ChangedComm()">
        <hr />
        <p>The Friis equation for propagation computes power received \(P_R\) based upon power transmitted \(P_T\),
            transmitter gain \(G_T\), receiver gain \(G_R\), wavelength \(\lambda\), and range \(R\).</p>
        <p>Range, \(R\) =
        <input type="number" id="friisrange" value="100" min ="0" max="99999" step="any" onchange="ChangedComm()">
        <select id="friisrangeexp" onchange="ChangedComm()">
            <option value="0">m</option>
            <option value="3" selected>km</option>
        </select></p>
        <p>Transmitter Power, \(P_T\) =
            <input type="number" id="powertransmitted" value="100" min ="0" max="99999" step="any" onchange="ChangedComm()">
            <select id="powertransmittedexp" onchange="ChangedComm()">
                <option value="-3">mW</option>
                <option value="0" selected>W</option>
                <option value="3">kW</option>
                <option value="6">MW</option>
            </select></p>
            <p id="friiseqn">eqn</p>
        <hr />
        <p>Often, it is necessary to solve for a maximum range \(R_{Max}\) (which we'll name \(R_{Friis}\)) based upon a minimum receive power \(P_{Rmin}\).</p>
           <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
           <input type="number" id="prminvalue" value="4" min ="0" max="99999" step="any" onchange="ChangedComm()">
           <select id="prminexp" onchange="ChangedComm()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12">pW</option>
            <option value="-9" selected>nW</option>
            <option value="-6">&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select></p>
           <p id="rmaxeqn">eqn</p>
        <hr />
        <p>For a given height \(h\) in feet, the radio-distance to the horizon \(R_{LOS}\) is computed in miles: \(R_{LOS}=\sqrt{2h}\). But when both Tx and Rx are elevated: \(R_{LOS}=\sqrt{2h_1}+\sqrt{2h_2}\)</p>
        <a>Transmitter height above ground: </a>
        <input type="number" id="txheight" value="5000" min="0" max="500000" value="1000" step="any" onchange="ChangedComm()">
        <a>ft. Distance to horizon is: </a><a id="txrlosmi">0</a><a> miles, </a><a id="txrloskm">0</a><a> km.</a>
        <br>
        <a>Receiver height above ground: </a>
        <input type="number" id="rxheight" value="3000" min="0" max="500000" value="1000" step="any" onchange="ChangedComm()">
        <a>ft. Distance to horizon is: </a><a id="rxrlosmi">0</a><a> miles, </a><a id="rxrloskm">0</a><a> km.</a>
        <br><br>
        <a>Whenever a comparison is made, convert \(R_{LOS}\) to kilometers:</a>
        <p id="rloseqn">eqn</p>
        <hr />
        <a>Communication is possible at distances within both limitations: \(R_{Friis}\) and \(R_{LOS}\), meaning that the lower value represents the maximum communication distance: </a>
        <p id="rcommeqn">eqn</p>
        </div>

        <!--COMM PICTURE TAB-->
        
    <div class="tabcontent" id="commpicture">
        <hr />
        <a>This is a visual representation of the scenario. Use the buttons to exaggerate the heights and Earth's curvature to more easily view the solution. These entries duplicate earlier entries on the page.</a><br>
        <a>Earth: </a><button onclick="ChangeEarth(1)">Rounder</button><button onclick="ChangeEarth(-1)">Flatter</button><br>
        <a>Heights: </a><button onclick="ChangeHeights(1)">Taller</button><button onclick="ChangeHeights(-1)">Shorter</button><br>
        <a>Gain Pattern: </a><button onclick="ChangeGainArc(1)">Tighter</button><button onclick="ChangeGainArc(-1)">Wider</button><br>
        
        
        <a>Frequency: </a><input type="number" id="lowerfreq" min="1" max="999" value="300" step="any" onchange="ChangedCommPicture()">
        <select id="lowerfreqexp" onchange="ChangedCommPicture()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6" selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>
        <a>Transmitter:</a>
        <select id="lowertxtype" onchange="ChangedCommPicture()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="lowertxtext">Radius (not diameter): </a>
        <input type="number" id="lowertxlength" min="1" max="999" value="1" step="any" onchange="ChangedCommPicture()">
        <select id="lowertxexp" onchange="ChangedCommPicture()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="lowertxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="lowertxeta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedCommPicture()">
        <br>
        <a>Gain:</a><input disabled type="number" id="lowertxgain" value="1" step="any" onchange="ChangedCommPicture()">
        <br>
        <a>Receiver:</a>
        <select id="lowerrxtype" onchange="ChangedCommPicture()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="lowerrxtext">Radius (not diameter): </a>
        <input type="number" id="lowerrxlength" min="1" max="999" value="1" step="any" onchange="ChangedCommPicture()">
        <select id="lowerrxexp" onchange="ChangedCommPicture()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="lowerrxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="lowerrxeta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedCommPicture()">
        <br>
        <a>Gain:</a><input disabled type="number" id="lowerrxgain" value="1" step="any" onchange="ChangedCommPicture()">
        <br>
        <a>Transmitter Power, \(P_T\) =
            <input type="number" id="lowerpowertrans" value="100" min ="0" max="99999" step="any" onchange="ChangedCommPicture()">
            <select id="lowerpowertransexp" onchange="ChangedCommPicture()">
                <option value="-3">mW</option>
                <option value="0" selected>W</option>
                <option value="3">kW</option>
                <option value="6">MW</option>
            </select></a>
        <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
            <input type="number" id="lowerprmin" value="4" min ="0" max="99999" step="any" onchange="ChangedCommPicture()">
            <select id="lowerprminexp" onchange="ChangedCommPicture()">
             <option value="-18">aW</option>
             <option value="-15">fW</option>
             <option value="-12">pW</option>
             <option value="-9" selected>nW</option>
             <option value="-6">&#181;W</option>
             <option value="-3">mW</option>
             <option value="0" >W</option>
         </select></a>
         <br>
         <a>Transmitter height above ground: </a>
        <input type="number" id="lowertxheight" value="5000" min="0" max="500000" value="1000" step="100" onchange="ChangedCommPicture()">
        <a>Receiver height above ground: </a>
        <input type="number" id="lowerrxheight" value="3000" min="0" max="500000" value="1000" step="100" onchange="ChangedCommPicture()">
        <a>Graphics will be skewed when both heights are \(0ft\).</a>
        <br>

        <div class="CanvasPlacement">
            <canvas class="flight-canvas" id="TheCanvas" width="1200" height="600" style="border:1px solid black"></canvas>
        </div>
    </div>

    <!--RADAR EQUATIONS TAB-->

    <div class="tabcontent" id="radarequations">
        <hr />
        <a>RADAR propagation is a 2-way path, which combines two Friis (1-way) computations that arrives at power received
             \(P_R\) based on power transmitted \(P_T\), transmitter/receiver gain \(G\), target \(RCS\), wavelength \(\lambda\), and range \(R\).</a><br>
        <a>Transmitter Power, \(P_T\) =
        <input type="number" id="radarpt" value="80" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarptexp" onchange="ChangedRadar()">
            <option value="-3">mW</option>
            <option value="0">W</option>
            <option value="3" selected>kW</option>
            <option value="6">MW</option>
        </select></a><br>
        <a>Gain: \(G\) = <input type="number" id="radargain" value="9002" onchange="ChangedRadar()" min="1" max="999999"></a><br>
        <a>Radar Cross Section: \(RCS\) = <input type="number" id="radarrcs" value="25" onchange="ChangedRadar()" min="1" max="999"></a>\(m^2\)
         (sometimes \(RCS\) is written with the symbol \(\sigma\))<br>
        <a>Frequency, \(f\) = <input type="number" id="radarfreq" value="3.5" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarfreqexp" onchange="ChangedRadar()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6">MHz</option>
            <option value="9" selected>GHz</option>
            <option value="12">THz</option>
        </select></a><br>
        <a>Range, \(R\) = <input type="number" id="radarrange" value="100" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarrangeexp" onchange="ChangedRadar()">
            <option value="0">m</option>
            <option value="3" selected>km</option>
        </select></a><br>
        <p id="radarpreqn">eqn</p>
        <a>To solve for a maximum RADAR range \(R_{Max}\) (which we'll name \(R_{Radar}\)) based upon a minimum receive power \(P_{Rmin}\).</a><br>
        <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
           <input type="number" id="radarprmin" value="1"  onchange="ChangedRadar()" min="1" max="999">
           <select id="radarprminexp" onchange="ChangedRadar()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12" selected>pW</option>
            <option value="-9">nW</option>
            <option value="-6">&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select></p>
        <p id="radarrmaxeqn">eqn</p>
        <a>Another important parameter of a basic RADAR system is the Pulse Repetition Frequency \(PRF\) which quantifies how often pulses are transmitted.
            The reciprocal of the \(PRF\) is the Pulse Reptition Interval \(PRI\). During the \(PRI\), the RADAR system is running
            a timer that associates returns with a distance according to the 2-way Range equation \(R=\frac{c t}{2}\). At the end of the \(PRI\) a
            new pulse is sent out and the timer is reset to \(0\). Very distant targets will thus cause returns to occur in a later \(PRI\) window and 
            lead to an "ambiguous" range reading. The maximum "unambiguous" range, \(R_{U}\) is the range reading when the round-trip travel time 
            to a target and back is equal to the \(PRI\).
        </a><br>
        <a>Pulse Repetition Frequency, \(PRF\) = <input type="number" id="radarPRF" value="1" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarPRFexp" onchange="ChangedRadar()">
            <option value="0">Hz</option>
            <option value="3" selected>kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select></a><br>
        <p id="radarrueqn">eqn</p>
        <a>The critical separation distance that quantifies a RADAR's ability to resolve two targets, Range Resolution, \(\Delta R\) depends upon the duration of the RADAR pulse,
            \(\tau\).</a><br>
        <a>Pulse Width, \(\tau\) = <input type="number" id="radarpw" value="100" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarpwexp" onchange="ChangedRadar()">
            <option value="-12">ps</option>
            <option value="-9" selected>ns</option>
            <option value="-6">&#181;s</option>
            <option value="-3">ms</option>
            <option value="0">s</option>
        </select></a><br>
        <p id="radarresolutioneqn">eqn</p>
        <a>A RADAR Warning Receiver (RWR) is a radio receiver tuned to the RADAR's frequency, and can normally detect the RADAR system if enough power reaches the RWR antenna.
            This is a one-way path that is evaluated with the Friis equation, where \(G_T\) is the RADAR antenna gain, and \(G_R\) is the RWR receiver gain.
            Normally, we'll compute a maximum range for the sake of comparison with other range-based metrics. To avoid confusion with other values of \(R_{Max}\),
            we'll name this value \(R_{RWR}\).
        </a><br>
        <a>RWR Gain, \(G_R\) = </a><input type="number" id="rwrgain" value="1.64" onchange="ChangedRadar()" min="1" max="999999"><br>
        <a>RWR Minimum Receive Power, \(P_{Rmin}\) = </a>
        <input type="number" id="rwrprmin" value="1" onchange="ChangedRadar()" min="1" max="999">
            <select id="rwrprminexp" onchange="ChangedRadar()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12">pW</option>
            <option value="-9">nW</option>
            <option value="-6" selected>&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select>
        <p id="radarrwreqn">eqn</p>
        <a>Both propagations, 2-way and 1-way, are limited to line-of-sight, so we'll compute \(R_{LOS}\).</a><br>
        <a>RADAR height above ground: </a>
        <input type="number" id="radarheight" value="10" min="0" max="50000" value="1000" onchange="ChangedRadar()">
        <a> ft. Target height above ground: </a>
        <input type="number" id="targetheight" value="10000" min="0" max="50000" value="1000" onchange="ChangedRadar()"><a> ft.</a>
        <p id="radarloseqn">eqn</p>
        <a>In determining "Who sees whom first?" the choice is somewhat involved. You may draw a picture or use the following concept: that we are finding
            which propagation case is less-limited. Separately, we'll check the final RADAR detection range against R<sub>U</sub> for ambiguous returns.
        </a>
        <p>\[ Max\begin{cases} Radar= & Min(R_{LOS},R_{Radar}) \\ RWR= & Min(R_{LOS},R_{RWR}) \end{cases}  \]</p>
        <p id="minmaxmessage">Min-Max</p>
        <a id="winnermessage">**</a>
        </a>
    </div>

    <!--DOPPLER TAB-->

    <div id="radardoppler" class="tabcontent">
        <hr />
        <p>The computations for \(R_{MAX}\) only help to determine whether a RADAR could detect a target.
            Actual range-finding is done by using the pulse's round-trip travel time and its known speed, \(c\).</p>
            <a>2-way travel time: \(t\) = <input type="number" id="radartime" value="1" onchange="ChangedDoppler()" min="1" max="999">
                <select id="radartimeexp" onchange="ChangedDoppler()">
                    <option value="-12">ps</option>
                    <option value="-9">ns</option>
                    <option value="-6">&#181;s</option>
                    <option value="-3" selected>ms</option>
                    <option value="0">s</option>
                </select></a><br>
        <p id="radartimedistanceeqn">eqn</p>
        <p>Of course, if you are measuring the time from just transmitter to receiver, do not divide by 2.</p>
            <a>1-way travel time: \(t\) = <input type="number" id="radiotime" value="1" onchange="ChangedDoppler()" min="1" max="999">
                <select id="radiotimeexp" onchange="ChangedDoppler()">
                    <option value="-12">ps</option>
                    <option value="-9">ns</option>
                    <option value="-6">&#181;s</option>
                    <option value="-3" selected>ms</option>
                    <option value="0">s</option>
                </select></a><br>
        <p id="radiotimedistanceeqn">eqn</p>
        <p>The Doppler effect is used to find a target's velocity. When the target is moving towards a RADAR, velocity
            is positive and the return frequency increases. When the target is moving away from a RADAR, return frequency will
            decrease. The sign can be entered as a negative velocity, by placing a '-' in place of \(\pm\)), or using a value of \(\theta\)
            that makes \(cos(\theta)\) negative. Choose one method.
        </p>
        <a>Frequency (original), \(f_0\) = <input type="number" id="radarFzero" value="2" onchange="ChangedDoppler()" min="1" max="999">
            <select id="radarFzeroexp" onchange="ChangedDoppler()">
                <option value="0">Hz</option>
                <option value="3">kHz</option>
                <option value="6">MHz</option>
                <option value="9" selected>GHz</option>
                <option value="12">THz</option>
            </select></a><br>
        <a>velocity, \(v\) = <input type="number" id="radarvelocity" value="100" onchange="ChangedDoppler()" min="1" max="999999"></a>\(m/s\)<br>
        <a>angle, \(\theta\) = <input type="number" id="radarangle" value="0" onchange="ChangedDoppler()" min="0" max="360"></a>&#176;<br>
        <a>To/From \(\pm\)</a><select id="radartowards" onchange="ChangedDoppler()">
        <option value="1" selected>Towards '+'</option>
        <option value="-1">Away   '-'</option></select>
        <p id="radarreturnfrequency">eqn</p>
        <p id="radarreturnshift">eqn</p>
        <a>In practice, a RADAR system will be used to compute velocity from the Doppler shift:</a><br>
        <a>Doppler Shift, \(\Delta f\) = <input type="number" id="radarShift" value="1.333" onchange="ChangedDoppler()" min="1" max="999">
            <select id="radarShiftexp" onchange="ChangedDoppler()">
                <option value="-3">mHz</option>
                <option value="0">Hz</option>
                <option value="3" selected>kHz</option>
                <option value="6">MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select></a><br>
        <p id="radarcomputevelocity">eqntocomputevelocity</p>
        <p>These Doppler equations disregard relativity and will be increasingly inaccurate at very high velocities.
        </p>
    </div>

    <!--JAMMING TAB-->

    <div id="radarjamming" class="tabcontent">
        <hr />
        COMING SOON!
    </div>

    <button id="nextsectionbutton" onclick="NextSection()">Next Section</button>
    <hr />
    Equation styling from <a href="https://www.mathjax.org">MathJax</a>
    <div style="font-size:10px;">
        Author: Thomas Kubler
    <a href="mailto:thomas.kubler@gmail.com">thomas.kubler@gmail.com</a>
    <a href="mailto:thomas.kubler@usafa.edu">thomas.kubler@usafa.edu</a>
</body>
</html>