<!DOCTYPE html>
<!--Author: Thomas Kubler. using examples from w3schools.com-->
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    
    <script defer src="ecescript.js"></script>
    <title>ECE 315 Examples</title>

    <!--<link href="styles.css" rel="stylesheet"> If the CSS goes overboard, the MathJax breaks-->

    <!-- MathJax for equations means the local styles has to be removed. Apache 2.0 license -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    <style>
        body{
            background-color: rgb(240,240,240);
        }
        .tablink {
            background-color: rgb(70,71,117);
            color: white;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 14px;
            font-size: 17px;
            width: 20%;
        }
        .tablink:hover {
            background-color: #33F;
        }
    </style>
</head>

<body onload="InitPage()">
    <h1>ECE 315 Examples</h1>
    <button class="tablink" onclick="openBigTab('DCCircuits',this)" >DC Circuits</button>
    <button class="tablink" onclick="openBigTab('ACCircuits',this)" >AC Circuits</button>
    <button class="tablink" onclick="openBigTab('Transmission',this)">Transmission</button>
    <button class="tablink" onclick="openBigTab('Distribution',this)">Distribution</button>
    <button class="tablink" onclick="openBigTab('Efficiency',this)">Efficiency</button>
    <br>
    <button class="tablink" onclick="openBigTab('ComplexNumbers',this)">Complex Numbers</button>
    <button class="tablink" onclick="openBigTab('InductorCapacitor',this)" >Inductor Capacitor</button>
    <button class="tablink" onclick="openBigTab('AnalogFilter',this)" >Analog Filter</button>
    <button class="tablink" onclick="openBigTab('TransducerInterface',this)"id="defaultOpen">Signal Conditioning</button>
    <button class="tablink" onclick="openBigTab('ADC',this)">ADC Data Rates</button>
    <br>
    <button class="tablink" onclick="openBigTab('commequations',this)">Communications</button>
    <button class="tablink" onclick="openBigTab('commpicture',this)">Comm Picture</button>
    <button class="tablink" onclick="openBigTab('radarequations',this)">RADAR</button>
    <button class="tablink" onclick="openBigTab('radardoppler',this)" >Doppler</button>
    <button class="tablink" onclick="openBigTab('radarjamming',this)">Jamming</button>

    <div class="tabcontent" id="DCCircuits">
        <hr />
        <!--<img src="static/CircuitOneR.PNG" alt="One Resistor Circuit" height="300">-->
        <p>Ohm's Law says that the current through a resistor is directly proportional to the applied voltage: \[V=I\times R\]</p>
        <p>Commonly, voltage and resistance are defined and we are computing the current: \[I=\frac{V}{R}\]</p>
        Voltage: <input type="number" id="virvoltage" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectvvir" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>
        Resistance: <input type="number" id="virresistance" min="1" max="999" value="100" step="any" onchange="ChangedDC()">
        <select id="selectrvir" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <p id="virequation">eqn</p>
        <hr />
        <p>Power is the product of voltage and current: \[P=V\times I\]</p>
        Voltage: <input type="number" id="pvivoltage" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectvpvi" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>
        Current: <input type="number" id="pvicurrent" min="1" max="999" value="120" step="any" onchange="ChangedDC()">
        <select id="selectipvi" onchange="ChangedDC()">
            <option value="-9">nA</option>
            <option value="-6">&#181;A</option>
            <option value="-3" selected>mA</option>
            <option value="0">A</option>
            <option value="3">kA</option>
            <option value="6">MA</option>
        </select>
        <p id="pviequation">eqn</p>
        <hr />
        <P>The next section uses the following DC circuit and an intermediate step for showing an \(R_{EQ}\):</P>
        <img src="static/CircuitThreeR.png" alt="Three-Resistor Circuit" height="300">
        <img src="static/CircuitThreeReq.png" alt="Three-Resistor Circuit EQ" height="300"><br>
        \(R_A\)=<input type="number" id="kvlra" min="1" max="999" value="1.7" step="any" onchange="ChangedDC()">
        <select id="selectkvlra" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0">&#8486;</option>
            <option value="3" selected>k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(R_B\)=<input type="number" id="kvlrb" min="1" max="999" value="3.3" step="any" onchange="ChangedDC()">
        <select id="selectkvlrb" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0">&#8486;</option>
            <option value="3" selected>k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(R_C\)=<input type="number" id="kvlrc" min="1" max="999" value="330" step="any" onchange="ChangedDC()">
        <select id="selectkvlrc" onchange="ChangedDC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        \(V_S\)=<input type="number" id="kvlv" min="1" max="999" value="12" step="any" onchange="ChangedDC()">
        <select id="selectkvlv" onchange="ChangedDC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select><br>
        <p>Computing an equivalent resistance helps to quickly simplify circuit analysis:</p>
        <p>Resistors in parallel add conductivity together (the inverse of resistance's ohm \( \Omega \) is conductivity's mho \( \mho \)):</p>
        <p id="resistanceparallel">eqn</p>
        <p>Resistors in series add resistance together:</p>
        <p id="resistanceseries">eqn</p>
        <p>For good practice, we'll wait until the final equivalent resistance before using the term \(R_{EQ}\) as it is the value
            that the voltage source will see as a single resistor. From Ohm's Law, the source current is:</p>
        <p id="kvlohms">eqn</p>
        <p>The source current will travel through \(R_A\) and then split between parallel resistors \(R_B\) and \(R_C\) according to the current divider (be careful
            with the 2-resistor current divider equation, the resistance value in the numerator is of the *other* resistor!):
        </p>
        <p id="currentdividerb">eqn</p>
        <p id="currentdividerc">eqn</p>
        <p>Verifying the current divider by finding each device's voltage will also demonstrate how the ratio of current is inversely proportional to the resistance ratio:</p>
        <p id="currentdividerverifyb">eqn</p>
        <p id="currentdividerverifyc">eqn</p>
        <p>A voltage divider can only be applied where the resistors are in series. Only after combining \(R_B\) and \(R_C\) into \(R_{BC}\),
            as shown in the right-most diagram, are the resistors in series. The voltage divider provides a shortcut by not computing current values:
        </p>
        <p id="voltagedivider">eqn</p>
        <p>Kirchhoff's Voltage Law states that over any loop in a circuit, the net voltage change is zero:
            \[\sum^{}_{loop}\Delta V=0 \text{ or: } \sum^{}_{loop}\Delta V_{up}=\sum^{}_{loop}\Delta V_{down}\]
            From the circuit above a KVL expression \(V_S=V_A+V_B\) could be used to find \(V_A\):</p>
        <p id="kvlkvl">eqn</p>
        <p>Kirchhoff's Current Law states that for any node in a circuit, the net current flow is zero:
            \[\sum^{}_{node}I=0 \text{ or: } \sum^{}_{node}I_{in}=\sum^{}_{node}I_{out}  \]
            In the above circuit, we could use the KCL expression \(I_B+I_C=I_S\) to verify our results:
        </p>
        <p id="kclkcl">eqn</p>
    </div>

    <div class="tabcontent" id="ACCircuits">
        <hr />
        <p>The generic form of an AC voltage signal (composed of a DC bias and one cosine) is: 
            \[v_s(t)=V_{B}+V_{m}cos(360^\circ f t+\phi)V\]
            Where \(V_B\) is the Bias (or DC component). \(V_m\) is the Magnitude.
            \(\phi\) is the Phase shift. \(f\) is the Frequency and can be derived from the signal's period \(T\) by the relationship:
            \[f=\frac{1}{T}\]
            For example, the period: <input type="number" id="ACperiod" min="1" max="999" value="16.667" step="any" onchange="ChangedAC()">
            <select id="selectACperiod" onchange="ChangedAC()">
                <option value="-12">ps</option>
                <option value="-9">ns</option>
                <option value="-6">&#181;s</option>
                <option value="-3" selected >ms</option>
                <option value="0">s</option>
            </select> correlates to the frequency:
        </p>
        <p id="periodfrequency">eqn</p>
        We can start with a graph of a cosine and derive the terms \(V_B, V_m,\) and \(f\).<br>
        \(V_{Max}=\)<input type="number" id="ACVmax" min="-999" max="999" value="24" step="any" onchange="ChangedAC()">
        <select id="selectACVmax" onchange="ChangedAC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3" >mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
        </select><br>
        \(V_{Min}=\)<input type="number" id="ACVmin" min="-999" max="999" value="-12" step="any" onchange="ChangedAC()">
        <select id="selectACVmin" onchange="ChangedAC()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3" >mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
        </select><br>
        \(\phi=\)<input type="number" id="ACphi" min="-360" max="360" value="90" step="any" onchange="ChangedAC()">\(^\circ\)<br>
        An \(R_{EQ}\) for power computations:
        <input type="number" id="rmsresistance" min="1" max="999" value="100" step="any" onchange="ChangedAC()">
        <select id="selectrmsr" onchange="ChangedAC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select><br>
        <canvas id="ACcanvas" width="801" height="401"></canvas>
        <canvas id="ACcanvasPower" width="801" height="401"></canvas><br>
        The magnitude \(V_m\) is one-half the voltage deviation:
        <p id="vmderived">eqn</p>
        The bias \(V_B\) is the average value:
        <p id="vbderived">eqn</p>
        The AC voltage signal is:
        <p id="acveqn">eqn</p>
        The RMS-value of the AC voltage is:
        <p id="acrms">eqn</p>
        The AC current equation can be found using Ohm's law and \(v_s(t)\):
        <p id="acieqn">eqn</p>
        The RMS-value of the AC current is:
        <p id="acirms">eqn</p>
        You can use functions of time, or RMS values, with Ohm's Law, KVL, KCL, and the current and voltage dividers.
        For example, after finding \(V_{S,RMS}\), finding \(I_{S,RMS}\) from \(R_{EQ}\) is trivial:
        <p id="acohms">eqn</p>
        RMS (Root-Mean-Squared) Voltage and Current values are used to compute average power. 
        \[P_{AVE}=I_{RMS}V_{RMS}=I_{RMS}^2 R=\frac{V_{RMS}^2}{R}\]
        Average Power from the example:
        <p id="acpave">eqn</p>
        Converting \(v_s(t)\) into \(V_{S,RMS}\) (or \(i_s(t)\) into \(I_{S,RMS}\)) is a clever way of accomplishing
        the calculus as the first step and it removes the variable \(t\) as well as abstracting a complex signal into a single value.
        We'll see the steps and how the RMS equation forms. Instead of using \(360^\circ\) we'll use \(2\pi\).
        To compute an average of a periodic function, integrate that function over one cycle and then divide by its width:
        \[P_{AVE}=\frac{1}{T}\int_{0}^{T} p(t) \,dt = \frac{1}{T}\int_{0}^{T} v(t)i(t) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} [V_B+V_m cos(2\pi f t+\phi)]\times [I_B+I_m cos(2\pi f t+\phi)] \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+ V_m I_m cos^2(2\pi f t+\phi) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+ \frac{V_m I_m}{2}+\frac{V_mI_m}{2}cos(4\pi f t+2\phi) \,dt \]
        \[ =\frac{1}{T}\int_{0}^{T} V_B I_B + \frac{V_m I_m}{2} + (V_m I_B + V_B I_m ) cos(2\pi f t+\phi)+\frac{V_mI_m}{2}cos(4\pi f t+2\phi) \,dt \]
        \[ =\frac{1}{T}[V_B I_B t + \frac{V_m I_m}{2}t + \frac{V_mI_B + V_BI_m}{2\pi f}sin(2\pi f t+\phi)+
            \frac{V_mI_m}{2\times4\pi f}sin(4\pi f t+2\phi)]\Big|_0^T \]
        \[ = V_BI_B+\frac{V_mI_m}{2}\]        
        <p id="acderive">eqn</p>
    </div>

    <div class="tabcontent" id="ComplexNumbers">
        <hr />
        <h4>Complex Number Formats: Rectangular, Polar, and Exponential</h4>
        Complex numbers (e.g \(2+3i\)) have a number of applications in electrical engineering (and to avoid confusion with current's \(i(t)\) we use \(j=\sqrt{-1}\)).
        If you have ever seen that \(e^{\pi i}-1=0\), then you can appreciate Euler's Formula (shown using \(j\)):
        \[e^{j\theta}=cos(\theta)+j sin(\theta)\]
        With another term \(A\) for an arbitrary magnitude, Euler's formula shows how to convert a complex number from its "Exponential" to 
        "Rectangular" (Cartesian) form. The variables are magnitude \(A\) and angle \(\theta\), and \(e\) and \(j\) are constants:
        \[Ae^{j\theta}=Acos(\theta)+j Asin(\theta)\]
        \[Real=Acos(\theta)\text{ and }Imag=Asin(\theta)\]
        <!--Why is this so useful? Recall that \(\frac{d}{dx} e^x=e^x\). When the complex number \(j\) is introduced as a constant coefficient to \(x\) it behaves like any other constant coefficient.
        In the case of \(e^x\) the derivative rotates each expression \(90^{\circ}\) around the complex plane, meaning that certain differential equations can be reduced to a geometry problem,
        and then further reduced to just Algebra.
        \[\frac{d}{dx} e^{jx}=je^{jx}\]
        \[\frac{d}{dx} je^{jx}=-e^{jx}\]
        \[-\frac{d}{dx} e^{jx}=-je^{jx}\]
        \[-\frac{d}{dx} je^{jx}=e^{jx}\]
        This same behavior is seen its rectangular form:
        \[\frac{d}{dx} [ cos(x)+j sin(x)] = -sin(x)+jcos(x)\]
        \[\frac{d}{dx} [-sin(x)+j cos(x)] = -cos(x)-jsin(x)\]
        \[\frac{d}{dx} [-cos(x)-j sin(x)] =  sin(x)-jcos(x)\]
        \[\frac{d}{dx} [ sin(x)-j cos(x)] =  cos(x)+jsin(x)\]-->
        Using the complex plane in the plot below, the positive real axis points to the right,
        and the positive imaginary axis points up. Angle \(0^{\circ}\) points to the right along the positive-real axis, and as the angle increases, the vector 
        rotates counter-clockwise through the four quadrants I, II, III and IV.
        <br>Magnitude \(A\): <input type="number" id="complexmag" min="0" max="10" value="10" step="any" onchange="ChangedComplex()">
        <br>Angle (deg) \(\theta\): <input type="number" id="complextheta" min="-360" max="360" value="30" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br><canvas id="canvasmagphase" width="250" height="250"></canvas>
        <br>To create the Rectangular form: 
        <p id="phasetorect">eqn</p>
        To create the "Polar" form, we replace the \(e^j\) with the "&#8736;" symbol (for now, it is this simple).
        <p id="phasorform">eqn</p>
        Adding complex values is most easily done with the Rectangular form. Add the terms piece-wise: Real with Real and Imaginary with Imaginary:
        \[Re_1+jIm_1+Re_2+jIm_2=Re_1+Re_2+j[Im_1+Im_2]\]
        Rectangular multiplication isn't very convenient, but it can be done (FOIL):
        \[(Re_1+jIm_1)\times(Re_2+jIm_2)=Re_1\times Re_2 - (Im_1\times Im_2)+ j(Re_1\times Im_2+Re_2\times Im_1)\]
        Rectangular division requires the use of the Complex Conjugate to rationalize the denominator and then distribute the division:
        (The Complex Conjugate of \([Re+jIm]\) is \([Re-jIm]\))
        \[\frac{Re_1+jIm_1}{Re_2+jIm_2}=\frac{(Re_1+jIm_1)}{(Re_2+jIm_2)}\times\frac{(Re_2-jIm_2)}{(Re_2-jIm_2)}=
        \frac{(Re_1\times Re_2 + Im_1\times Im_2)+ j(Re_2\times Im_1-Re_1\times Im_2)}{Re_2^2+Im_2^2}=
        \frac{Re_1\times Re_2 + Im_1\times Im_2}{Re_2^2+Im_2^2}+j\frac{Re_2\times Im_1-Re_1\times Im_2}{Re_2^2+Im_2^2}\]
        Multiplication is much easier in Exponential and Polar forms:
        \[A_1e^{j\theta_1}\times A_2e^{j\theta_2}=A_1\times A_2e^{j(\theta_1+\theta_2)}\text{  and  }\frac{A_1e^{j\theta_1}}{A_2e^{j\theta_2}}=\frac{A_1}{A_2}e^{j(\theta_1-\theta_2)}\]
        \[A_1\angle\theta_1 \times A_2\angle \theta_2=A_1\times A_2\angle \theta_1+\theta_2\ \text{  and  }\frac{A_1\angle\theta_1}{A_2\angle\theta_2}=\frac{A_1}{A_2}\angle\theta_1-\theta_2\]
        To go from "Rectangular" to "Polar" use the Pythagorean Theorem for magnitude \(A=\sqrt{Real^2+Imag^2}\) and an arctangent function to obtain the angle that satisfies
            \(tan(\theta)=\frac{Imag}{Real}\). Beware: the computation \(\theta=tan^{-1}(\frac{Imag}{Real})\)  is only correct in quadrants I and IV. Use \(atan2\) or a calculator's complex phasor 
            functionality to correctly compute angles when the complex number is in Quadrants II and III.
            If you must use \(tan^{-1}\) add \(180^{\circ}\) to the result whenever the real component is negative.
            Then, whenever \(\phi\) exceeds \(180^{\circ}\) subtract \(360^{\circ}\) (I won't show this final step -- 
            your efforts are better spent learning how to have your calculator provide phase in a single step).
        <p id="recttomagnitude">eqn</p>
        <p id="recttophase">eqn</p>
        <p id="complexfixphase">eqn</p>
        <hr />
        <h4>Phasor Transform</h4>
        Complex numbers appear in circuits when using the Phasor Transform, which removes time and frequency, leaving an expression of magnitude and phase.
        \[v_s(t)=V_m cos(360^{\circ}ft+\phi)\]
        \[Phasor\{v_s(t)\}=V_s\]
        \[V=V_m\angle\phi\]
        The transform is also reversible, but frequency has to take on its original value. And it is only valid for expressions of
        voltage or current. Assume \(f=60Hz\)
        \[I=3\angle 45^{\circ}A\]
        \[i(t)=3cos(360^{\circ}60t+45^{\circ})A\]
        Depending on the textbook, the Phasor Transform's magnitude will be the RMS-value (thus, divide by \(\sqrt{2}\) where applicable).
        You can choose whether or not to convert to RMS and back - just keep track - it is sometimes easier to remain in peak, but remember average power uses RMS.
        Thankfully, we won't do any power computations in this subject area.
        <hr />
        <h4>Phasor Addition</h4>
        So lets try to add up two voltage sources both operating at the same frequency (a must with Phasors) connected in series. Assume \(f=100Hz\)
        <br>Magnitude \(V_{m1}\): <input type="number" id="complexvm1" min="0" max="10" value="7" step="any" onchange="ChangedComplex()">V
        <br>Angle (deg) \(\phi_1\): <input type="number" id="complext1" min="-360" max="360" value="30" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br>Magnitude \(V_{m2}\): <input type="number" id="complexvm2" min="0" max="10" value="5" step="any" onchange="ChangedComplex()">V
        <br>Angle (deg) \(\phi_2\): <input type="number" id="complext2" min="-360" max="360" value="145" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br>A computer can of course perform the addition at several hundred values of \(t\) and plot the result. But we'll take advantage of the property that these two cosines are always the same
        phase apart, and that their sum will be a single cosine at this frequency, only adjusted in magnitude and phase: Phasors tolerate addition. If they are close in phase, they are constructive. If they are 
        far apart in phase, they are destructive. Instead of using geometry, we'll convert functions into their Phasors and then perform addition, before returning to the time-domain:
        <p id="complexaddend1">eqn</p>
        <p id="complexaddend2">eqn</p>
        <p id="complexaddition">eqn</p>
        <p id="complexresult">eqn</p>
        <canvas id="canvasaddvoltage" width="1000" height="250"></canvas> 
        <br><canvas id="canvasaddvectors" width="250" height="250"></canvas>
        <br><button onclick="animatecomplex()">Animate</button><button onclick="stopanimatecomplex(false)">Stop</button><button onclick="stopanimatecomplex(true)">Reset</button>
        <br>A Voltage (or Current) Phasor is not itself a time-based value, but if we rotate the Phasors about the origin, then the Real components of the Complex Phasors
        represent the value that would be seen on the graph of \(v(t)\) just above. The animation demonstrates that because the two voltage sources operate at the same
        frequency, their Phasor sum will also "rotate" at that frequency. In fact, for any number of sinusoids (not just two) of the same frequency, their sum will be a single
        sinusoid at that frequency.
        <hr />
        <h4>Phasor Multiplication</h4>
        Word of warning: we do <strong>not</strong> multiply two voltage phasors together, nor two current, nor a voltage and a current. Why? Linearity.
        When we multiply our function by a <strong>constant</strong> the calculus is unaffected:
        \[ \int 2cos(x) \,dx = 2\int cos(x) \,dx\]
        \[\frac{d}{dx}4cos(x)=4\frac{d}{dx}cos(x)\]
        However, if we attempt to take the product of two functions, the calculus can be wildly different.
        For trigonmetric functions, the frequencies will also change.
        \[\frac{d}{dx}[cos(x)]=-sin(x)\]
        \[\frac{d}{dx}[cos(x)\times cos(x)]=-2sin(x)\times cos(x)=-sin(2x)\]
        The multiplication we can do is of the form \(V=I Z\) where \(Z\) is the Impedance of a Resistor, Capacitor, or Inductor.
    </div>

    <div class="tabcontent" id="InductorCapacitor">
        <p>Our passive circuit components are the resistor (R), inductor (L), and capacitor (C). Using the same form as Ohm's Law, we introduce 
            the concept of impedance which quantifies the relationship between \(V\) and \(I\) in the term \(Z\), a complex number.
        </p>
        \[\text{Resistor: }v_R(t)=i(t)R\rightarrow Z_R=R\]
        \[\text{Inductor: }v_L(t)=L\frac{di}{dt}\rightarrow Z_L=j\omega L\]
        \[\text{Capacitor: }i_C(t)=C\frac{dv}{dt}\rightarrow Z_C=\frac{1}{j\omega C}\]
        \[\text{where: }\omega=2\pi f\]
        Let's see what kind of impedance values that typical inductors and capacitors take on with different frequencies:
        <br>Frequency: <input type="number" id="ICfreq" min="1" max="999" value="60" step="any" onchange="ChangedIC()">
        <select id="ICfreqexp" onchange="ChangedIC()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Resistance: <input type="number" id="ICresistance" min="1" max="999" value="50" step="any" onchange="ChangedIC()">
        <select id="ICresistanceP" onchange="ChangedIC()">
            <option value="-3">m&#8486;</option>
            <option value="0" selected>&#8486;</option>
            <option value="3">k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <br>Inductance: <input type="number" id="inductorvalue" min="1" max="999" value="142" step="any" onchange="ChangedIC()">
        <select id="inductorvalueexp" onchange="ChangedIC()">
            <option value="-6">&#181;H</option>
            <option value="-3" selected>mH</option>
            <option value="0">H</option>
        </select>
        <br>Capacitance: <input type="number" id="capacitancevalue" min="1" max="999" value="160" step="any" onchange="ChangedIC()">
        <select id="capacitancevalueexp" onchange="ChangedIC()">
            <option value="-12">pF</option>
            <option value="-9" >nF</option>
            <option value="-6"selected>&#181;F</option>
            <option value="-3" >mF</option>
            <option value="0">F</option>
        </select>
        <p id="ICrexp">eqn</p>
        <p id="inductorimpedance">eqn</p>
        <p id="capacitorimpedance">eqn</p>
        <p>Let's build a circuit using your values and plot \(v_s(t)\) and \(i_s(t)\). Choose a topology:
            <select id="topology" onchange="ChangedIC()">
                <option value="SRLC" selected >Series RLC</option>
                <option value="SRC">Series RC</option>
                <option value="SRL">Series RL</option>
                <option value="SLC">Series LC</option>
                <option value="PRLC">Parallel RLC</option>
                <option value="PRC">Parallel RC</option>
                <option value="PRL">Parallel RL</option>
                <option value="PLC">Parallel LC</option>
            </select>
        </p>
        <p id="ICzeq">Zeq eqn</p>
        <p id="ICvoltageeqn">Veqn</p>
        <p id="ICcurrenteqn">Ieqn</p>
        Current per grid square <select id="currentzoom" onchange="ChangedIC()">
            <option value=5>100 kA</option>
            <option value=4>10 kA</option>
            <option value=3>1 kA</option>
            <option value=2>100 A</option>
            <option value=1>10 A</option>
            <option value=0>1 A</option>
            <option value=-1 selected>100 mA</option>
            <option value=-2>10 mA</option>
            <option value=-3>1 mA</option>
            <option value=-4>100 &#181;A</option>
        </select>
        Time per grid square <select id="timezoom" onchange="ChangedIC()">
            <option value=-12>1 ps</option>
            <option value=-11>10 ps</option>
            <option value=-10>100 ps</option>
            <option value=-9>1 ns</option>
            <option value=-8>10 ns</option>
            <option value=-7>100 ns</option>
            <option value=-6>1 &#181;s</option>
            <option value=-5>10 &#181;s</option>
            <option value=-4>100 &#181;s</option>
            <option value=-3 selected>1 ms</option>
            <option value=-2>10 ms</option>
            <option value=-1>100 ms</option>
            <option value=0>1 s</option>
        </select>
        <label for="accept">
            <input type="checkbox" id="autoscaleIC" name="accept" value="yes" checked onchange="ChangedIC()">  Auto Scale 
         </label><br>    
        <canvas id="canvasICplot" width="1000" height="250"></canvas> 
    </div>

    <div class="tabcontent" id="AnalogFilter">
        <p>Combinations of Resistors, Capacitors, and Inductors can be used as filters based upon their frequency response. We will consider
            the source to the input, and one of the components will be the output. Thus the filter's behavior at any single frequency can be
            computed using a ratio of the output voltage to the input voltage as such:
        </p>
        \[Gain=\frac{V_o}{V_i}\]
        <!--
        <p>Typically, \(Gain\) can be computed by creating a voltage divider. For example, an RC filter will have \(Gain\):</p>
        \[Gain=\frac{Z_C}{Z_R+Z_C}=\frac{\frac{1}{j\omega C}}{R+\frac{1}{j\omega C}}
            =\frac{\frac{1}{j\omega C}}{R+\frac{1}{j\omega C}}\times\frac{j\omega C}{j\omega C} =\frac{1}{1+j\omega RC}\]
        \[\frac{1}{1+j\omega RC}=\frac{1\angle 0}{\sqrt{1^2+\omega^2 R^2 C^2}\angle tan^{-1}(\frac{\omega R C}{1})}
            =\frac{1}{\sqrt{1+\omega^2R^2C^2}}\angle -tan^{-1}(\frac{\omega R C}{1})=\frac{1}{\sqrt{1+\omega^2R^2C^2}}\angle tan^{-1}(-\omega R C)\]
        <p>We know that the second device in the name RC is "C" so the capacitor will be the output component. This is because its ground
            terminal will be shared with the input's ground terminal, which follows the rule of maintaining a common ground. It is not always 
            necessary, but a common ground should be used whenever possible.
            <br>For series filters (RC, CR, LR, RL), the steps to creating this expression for gain (seen above) are as follows:
            <br>1. Create the ratio of impedances in the form \(Gain=\frac{Z_{2}}{Z_1+Z_2}\)
            <br>2. Multiply through by the reciprocal of \(Z_2\) because it appears twice in the expression.
                Result is now \(Gain=\frac{1}{\frac{Z_1}{Z_2}+1}\)
            <br>3. Change the numerator into its Polar form: \(1\angle 0\).
            <br>4. Change the denominator into its Polar form: \(\sqrt{1+[Imag]^2}\angle tan^{-1}({Imag})\)
            <br>5. The resultant quotient is: \(\frac{1}{\sqrt{1+[Imag]^2}}\angle tan^{-1}(-[Imag])\) where \([Imag]\) is the 
            imaginary component of \(1+\frac{Z_1}{Z_2}\). Its Real component is just \(1\) and is thus omitted from \(tan^{-1}\).
        </p>-->
        <br>Frequency: <input type="number" id="FilterFreq0" min="1" max="999" value="400" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq0P" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Resistance: <input type="number" id="FilterR" min="1" max="999" value="10" step="any" onchange="ChangedFilter()">
        <select id="FilterRP" onchange="ChangedFilter()">
            <option value="-3">m&#8486;</option>
            <option value="0" >&#8486;</option>
            <option value="3" selected>k&#8486;</option>
            <option value="6">M&#8486;</option>
            <option value="9">G&#8486;</option>
        </select>
        <br>Inductance: <input type="number" id="FilterL" min="1" max="999" value="200" step="any" onchange="ChangedFilter()">
        <select id="FilterLP" onchange="ChangedFilter()">
            <option value="-6">&#181;H</option>
            <option value="-3" selected>mH</option>
            <option value="0">H</option>
        </select>
        <br>Capacitance: <input type="number" id="FilterC" min="1" max="999" value="40" step="any" onchange="ChangedFilter()">
        <select id="FilterCP" onchange="ChangedFilter()">
            <option value="-12">pF</option>
            <option value="-9"selected >nF</option>
            <option value="-6">&#181;F</option>
            <option value="-3" >mF</option>
            <option value="0">F</option>
        </select>
        <br>Choose a topology and we'll create expressions for Gain:
            <select id="Filtertopology" onchange="ChangedFilter()">
                <option value="SRLC"  >Series RLC</option>
                <option value="SRC" selected>Series RC</option>
                <option value="SCR">Series CR</option>
                <option value="SRL" >Series RL</option>
                <option value="SLR" >Series LR</option>
                <option value="SLC">Series LC</option>
                <option value="SCL">Series CL</option>
            </select>
        <p id="FilterGain">FilterGain</p>
        <p id="FilterGainFinish">FilterGainFinish</p>
        And plot this Gain over a range of frequencies (both axes on logarithmic scale):
        <br>Start Frequency: <input type="number" id="FilterFreq1" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq1P" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Stop Frequency: <input type="number" id="FilterFreq2" min="1" max="999" value="1" step="any" onchange="ChangedFilter()">
        <select id="FilterFreq2P" onchange="ChangedFilter()">
            <option value="0" >Hz</option>
            <option value="3" >kHz</option>
            <option value="6"selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>Max Gain: <select id="BodeMaxP" onchange="ChangedFilter()">
            <option value="3">1000.0</option>
            <option value="2">100.0</option>
            <option value="1" selected>10.</option>
            <option value="0">1.0</option>
        </select>
        <br>Min Gain: <select id="BodeMinP" onchange="ChangedFilter()">
            <option value="-3" >0.001</option>
            <option value="-6" >0.000001</option>
            <option value="-9" selected>0.000000001</option>
            <option value="-12">0.000000000001</option>
            <option value="-15">0.000000000000001</option>
        </select>
        <br><canvas id="canvasBODE" width="1200" height="500" onclick="LabelFrequencyResponse(event)"></canvas> 
        <br><button id="BodeLeftDec" onclick="BodeSlew(-10)">Decade Left</button>
        <button id="BodeLeft" onclick="BodeSlew(-1)">Step Left</button>
        <button id="BodeRight" onclick="BodeSlew(1)">Step Right</button>
        <button id="BodeRightDec" onclick="BodeSlew(10)">Decade Right</button>
        <hr />
        <br>
        Voltage: <input type="number" class="SignalV" min="1" max="999" value="10" step="any" onchange="ChangedFilter()">
        <select class="SignalVP" onchange="ChangedFilter()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        Frequency: <input type="number" class="SignalF" min="1" max="999" value="100" step="any" onchange="ChangedFilter()">
        <select class="SignalFP" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Phase \(\phi\): <input type="number" class="SignalPhase"  min="-360" max="360" value="0" step="any" onchange="ChangedFilter()"> \(^{\circ}\)
        <br>
        Voltage: <input type="number" class="SignalV" min="1" max="999" value="3.3" step="any" onchange="ChangedFilter()">
        <select class="SignalVP" onchange="ChangedFilter()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>Frequency: <input type="number" class="SignalF" min="1" max="999" value="300" step="any" onchange="ChangedFilter()">
        <select class="SignalFP" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Phase \(\phi\): <input type="number" class="SignalPhase"  min="-360" max="360" value="180" step="any" onchange="ChangedFilter()"> \(^{\circ}\)
        <br>
        Voltage: <input type="number" class="SignalV" min="1" max="999" value="2" step="any" onchange="ChangedFilter()">
        <select class="SignalVP" onchange="ChangedFilter()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        Frequency: <input type="number" class="SignalF" min="1" max="999" value="500" step="any" onchange="ChangedFilter()">
        <select class="SignalFP" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3" >kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Phase \(\phi\): <input type="number" class="SignalPhase" min="-360" max="360" value="0" step="any" onchange="ChangedFilter()"> \(^{\circ}\)
        <br>
        Voltage: <input type="number" class="SignalV" min="1" max="999" value="1.43" step="any" onchange="ChangedFilter()">
        <select class="SignalVP" onchange="ChangedFilter()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        Frequency: <input type="number" class="SignalF" min="1" max="999" value="700" step="any" onchange="ChangedFilter()">
        <select class="SignalFP" onchange="ChangedFilter()">
            <option value="0" selected>Hz</option>
            <option value="3">kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        Phase \(\phi\): <input type="number" class="SignalPhase"  min="-360" max="360" value="180" step="any" onchange="ChangedComplex()"> \(^{\circ}\)
        <br><canvas id="canvasFilterTime" width="1200" height="500" onclick="LabelFrequencyResponse(event)"></canvas> 
        <br><canvas id="canvasFilterSpectrum" width="1200" height="500" onclick="LabelFrequencyResponse(event)"></canvas> 
    </div>

    <div class="tabcontent" id="TransducerInterface">
        Build and test a transducer Interface
        <br>Sensor Voltage A: <input type="number" id="sensora" min="-999" max="999" value="-200" step="any" onchange="ChangedTransducer()">
        <select id="sensorap" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0" >V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        ADC Voltage A: <input type="number" id="adca" min="-999" max="999" value="0" step="any" onchange="ChangedTransducer()">
        <select id="adcap" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>Sensor Voltage B: <input type="number" id="sensorb" min="-999" max="999" value="200" step="any" onchange="ChangedTransducer()">
        <select id="sensorbp" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0">V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        ADC Voltage B: <input type="number" id="adcb" min="-999" max="999" value="5" step="any" onchange="ChangedTransducer()">
        <select id="adcbp" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3">mV</option>
            <option value="0" selected>V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <br>Test Sensor Voltage: <input type="number" id="testvoltage" min="-999" max="999" value="0" step="any" onchange="ChangedTransducer()">
        <select id="testvoltagep" onchange="ChangedTransducer()">
            <option value="-9">nV</option>
            <option value="-6">&#181;V</option>
            <option value="-3"selected>mV</option>
            <option value="0" >V</option>
            <option value="3">kV</option>
            <option value="6">MV</option>
        </select>
        <p>Beware that the ADC Min may match to the Sensor Max. For that reason, assign the values "A" and "B" as opposed to Min/Max.</p>
        <p id="Keqn">Compute K</p>
        <p id="Beqn">Compute B</p>
        <p id="Vout">Compute Vout</p>
        <br>ADC Sample Size (b=): <input type="number" id="bitsize" min="1" max="128" value="8" step="any" onchange="ChangedTransducer()">
        <p id="deltaV">Compute DV</p>
        <p id="evallevel">Compute ELandQL</p>
        <p id="quantizationerror">Compute QE</p>
    </div>

    <div class="tabcontent" id="commequations">
        <hr />
        <p>The wavelength of a radio transmission can be computed using the speed of light \(c\) and the radio frequency \(f\):</p>
        <a>Frequency: </a>
        <input type="number" id="commfreqarg" min="1" max="999" value="300" step="any" onchange="ChangedComm()">
        <select id="commfreqexp" onchange="ChangedComm()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6" selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <p id="lambdaeqn">eqn</p>
        <hr />
        <p>The gain \(G\) of a parabolic dish antenna of radius \(r\), efficiency \(\eta\), and wavelength \(\lambda\):
            \[G={(2\pi r)^2\over \lambda^2}\eta\]</p>
        <p>The monopole antenna achieves an ideal gain \(G=3.24\) at it's ideal length, one-quarter wavelength: \(L={\lambda \over 4}\) </p>
        <p>The dipole antenna achieves an ideal gain \(G=1.64\) at it's ideal length, one-half wavelength: \(L={\lambda \over 2}\)</p>
        <a>Transmitter:</a>
        <select id="transmittertype" onchange="ChangedComm()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3">Parabolic</option>
            <option value="4"selected>Unspecified</option>
        </select><br>
        <a id="txlengthtext">Radius (not diameter): </a>
        <input type="number" id="txantennalength" min="1" max="999" value="1" step="any" onchange="ChangedComm()">
        <select id="txantennaexp" onchange="ChangedComm()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="txetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="txdisheta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedComm()">
        <br>
        <a>Gain:</a><input disabled type="number" id="txgain" value="2" step="any" onchange="ChangedComm()">
        <br><br>
        <a>Receiver:</a>
        <select id="receivertype" onchange="ChangedComm()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="rxlengthtext">Radius (not diameter): </a>
        <input type="number" id="rxantennalength" min="1" max="999" value="1" step="any" onchange="ChangedComm()">
        <select id="rxantennaexp" onchange="ChangedComm()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="rxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="rxdisheta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedComm()">
        <br>
        <a>Gain:</a><input disabled type="number" id="rxgain" value="1" step="any" onchange="ChangedComm()">
        <hr />
        <p>The Friis equation for propagation computes power received \(P_R\) based upon power transmitted \(P_T\),
            transmitter gain \(G_T\), receiver gain \(G_R\), wavelength \(\lambda\), and range \(R\).</p>
        <p>Range, \(R\) =
        <input type="number" id="friisrange" value="100" min ="0" max="99999" step="any" onchange="ChangedComm()">
        <select id="friisrangeexp" onchange="ChangedComm()">
            <option value="0">m</option>
            <option value="3" selected>km</option>
        </select></p>
        <p>Transmitter Power, \(P_T\) =
            <input type="number" id="powertransmitted" value="100" min ="0" max="99999" step="any" onchange="ChangedComm()">
            <select id="powertransmittedexp" onchange="ChangedComm()">
                <option value="-3">mW</option>
                <option value="0" selected>W</option>
                <option value="3">kW</option>
                <option value="6">MW</option>
            </select></p>
            <p id="friiseqn">eqn</p>
        <hr />
        <p>Often, it is necessary to solve for a maximum range \(R_{Max}\) (which we'll name \(R_{Friis}\)) based upon a minimum receive power \(P_{Rmin}\).</p>
           <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
           <input type="number" id="prminvalue" value="4" min ="0" max="99999" step="any" onchange="ChangedComm()">
           <select id="prminexp" onchange="ChangedComm()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12">pW</option>
            <option value="-9" selected>nW</option>
            <option value="-6">&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select></p>
           <p id="rmaxeqn">eqn</p>
        <hr />
        <p>For a given height \(h\) in feet, the radio-distance to the horizon \(R_{LOS}\) is computed in miles: \(R_{LOS}=\sqrt{2h}\). But when both Tx and Rx are elevated: \(R_{LOS}=\sqrt{2h_1}+\sqrt{2h_2}\)</p>
        <a>Transmitter height above ground: </a>
        <input type="number" id="txheight" value="5000" min="0" max="500000" value="1000" step="any" onchange="ChangedComm()">
        <a>ft. Distance to horizon is: </a><a id="txrlosmi">0</a><a> miles, </a><a id="txrloskm">0</a><a> km.</a>
        <br>
        <a>Receiver height above ground: </a>
        <input type="number" id="rxheight" value="3000" min="0" max="500000" value="1000" step="any" onchange="ChangedComm()">
        <a>ft. Distance to horizon is: </a><a id="rxrlosmi">0</a><a> miles, </a><a id="rxrloskm">0</a><a> km.</a>
        <br><br>
        <a>Whenever a comparison is made, convert \(R_{LOS}\) to kilometers:</a>
        <p id="rloseqn">eqn</p>
        <hr />
        <a>Communication is possible at distances within both limitations: \(R_{Friis}\) and \(R_{LOS}\), meaning that the lower value represents the maximum communication distance: </a>
        <p id="rcommeqn">eqn</p>
        </div>

        <!--COMM PICTURE TAB-->
        
    <div class="tabcontent" id="commpicture">
        <hr />
        <a>This is a visual representation of the scenario. Use the buttons to exaggerate the heights and Earth's curvature to more easily view the solution. These entries duplicate earlier entries on the page.</a><br>
        <a>Earth: </a><button onclick="ChangeEarth(1)">Rounder</button><button onclick="ChangeEarth(-1)">Flatter</button><br>
        <a>Heights: </a><button onclick="ChangeHeights(1)">Taller</button><button onclick="ChangeHeights(-1)">Shorter</button><br>
        <a>Gain Pattern: </a><button onclick="ChangeGainArc(1)">Tighter</button><button onclick="ChangeGainArc(-1)">Wider</button><br>
        
        
        <a>Frequency: </a><input type="number" id="lowerfreq" min="1" max="999" value="300" step="any" onchange="ChangedCommPicture()">
        <select id="lowerfreqexp" onchange="ChangedCommPicture()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6" selected>MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select>
        <br>
        <a>Transmitter:</a>
        <select id="lowertxtype" onchange="ChangedCommPicture()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="lowertxtext">Radius (not diameter): </a>
        <input type="number" id="lowertxlength" min="1" max="999" value="1" step="any" onchange="ChangedCommPicture()">
        <select id="lowertxexp" onchange="ChangedCommPicture()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="lowertxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="lowertxeta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedCommPicture()">
        <br>
        <a>Gain:</a><input disabled type="number" id="lowertxgain" value="1" step="any" onchange="ChangedCommPicture()">
        <br>
        <a>Receiver:</a>
        <select id="lowerrxtype" onchange="ChangedCommPicture()">
            <option value="1">Dipole</option>
            <option value="2">Monopole</option>
            <option value="3" selected>Parabolic</option>
            <option value="4">Unspecified</option>
        </select><br>
        <a id="lowerrxtext">Radius (not diameter): </a>
        <input type="number" id="lowerrxlength" min="1" max="999" value="1" step="any" onchange="ChangedCommPicture()">
        <select id="lowerrxexp" onchange="ChangedCommPicture()">
            <option value="-3">mm</option>
            <option value="0" selected>m</option>
            <option value="3">km</option>
        </select>
        <br>
        <a id="lowerrxetatext">Reflective Efficiency (max 1.0): </a>
        <input type="number" id="lowerrxeta" min="0" max="1" value="0.7" step="0.01" onchange="ChangedCommPicture()">
        <br>
        <a>Gain:</a><input disabled type="number" id="lowerrxgain" value="1" step="any" onchange="ChangedCommPicture()">
        <br>
        <a>Transmitter Power, \(P_T\) =
            <input type="number" id="lowerpowertrans" value="100" min ="0" max="99999" step="any" onchange="ChangedCommPicture()">
            <select id="lowerpowertransexp" onchange="ChangedCommPicture()">
                <option value="-3">mW</option>
                <option value="0" selected>W</option>
                <option value="3">kW</option>
                <option value="6">MW</option>
            </select></a>
        <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
            <input type="number" id="lowerprmin" value="4" min ="0" max="99999" step="any" onchange="ChangedCommPicture()">
            <select id="lowerprminexp" onchange="ChangedCommPicture()">
             <option value="-18">aW</option>
             <option value="-15">fW</option>
             <option value="-12">pW</option>
             <option value="-9" selected>nW</option>
             <option value="-6">&#181;W</option>
             <option value="-3">mW</option>
             <option value="0" >W</option>
         </select></a>
         <br>
         <a>Transmitter height above ground: </a>
        <input type="number" id="lowertxheight" value="5000" min="0" max="500000" value="1000" step="100" onchange="ChangedCommPicture()">
        <a>Receiver height above ground: </a>
        <input type="number" id="lowerrxheight" value="3000" min="0" max="500000" value="1000" step="100" onchange="ChangedCommPicture()">
        <a>Graphics will be skewed when both heights are \(0ft\).</a>
        <br>

        <div class="CanvasPlacement">
            <canvas class="flight-canvas" id="TheCanvas" width="1200" height="600" style="border:1px solid black"></canvas>
        </div>
    </div>

    <!--RADAR EQUATIONS TAB-->

    <div class="tabcontent" id="radarequations">
        <hr />
        <a>RADAR propagation is a 2-way path, which combines two Friis (1-way) computations that arrives at power received
             \(P_R\) based on power transmitted \(P_T\), transmitter/receiver gain \(G\), target \(RCS\), wavelength \(\lambda\), and range \(R\).</a><br>
        <a>Transmitter Power, \(P_T\) =
        <input type="number" id="radarpt" value="80" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarptexp" onchange="ChangedRadar()">
            <option value="-3">mW</option>
            <option value="0">W</option>
            <option value="3" selected>kW</option>
            <option value="6">MW</option>
        </select></a><br>
        <a>Gain: \(G\) = <input type="number" id="radargain" value="9002" onchange="ChangedRadar()" min="1" max="999999"></a><br>
        <a>Radar Cross Section: \(RCS\) = <input type="number" id="radarrcs" value="25" onchange="ChangedRadar()" min="1" max="999"></a>\(m^2\)
         (sometimes \(RCS\) is written with the symbol \(\sigma\))<br>
        <a>Frequency, \(f\) = <input type="number" id="radarfreq" value="3.5" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarfreqexp" onchange="ChangedRadar()">
            <option value="0">Hz</option>
            <option value="3">kHz</option>
            <option value="6">MHz</option>
            <option value="9" selected>GHz</option>
            <option value="12">THz</option>
        </select></a><br>
        <a>Range, \(R\) = <input type="number" id="radarrange" value="100" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarrangeexp" onchange="ChangedRadar()">
            <option value="0">m</option>
            <option value="3" selected>km</option>
        </select></a><br>
        <p id="radarpreqn">eqn</p>
        <a>To solve for a maximum RADAR range \(R_{Max}\) (which we'll name \(R_{Radar}\)) based upon a minimum receive power \(P_{Rmin}\).</a><br>
        <a>Minimum Receive Power, \(P_{Rmin}\) =</a>
           <input type="number" id="radarprmin" value="1"  onchange="ChangedRadar()" min="1" max="999">
           <select id="radarprminexp" onchange="ChangedRadar()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12" selected>pW</option>
            <option value="-9">nW</option>
            <option value="-6">&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select></p>
        <p id="radarrmaxeqn">eqn</p>
        <a>Another important parameter of a basic RADAR system is the Pulse Repetition Frequency \(PRF\) which quantifies how often pulses are transmitted.
            The reciprocal of the \(PRF\) is the Pulse Reptition Interval \(PRI\). During the \(PRI\), the RADAR system is running
            a timer that associates returns with a distance according to the 2-way Range equation \(R=\frac{c t}{2}\). At the end of the \(PRI\) a
            new pulse is sent out and the timer is reset to \(0\). Very distant targets will thus cause returns to occur in a later \(PRI\) window and 
            lead to an "ambiguous" range reading. The maximum "unambiguous" range, \(R_{U}\) is the range reading when the round-trip travel time 
            to a target and back is equal to the \(PRI\).
        </a><br>
        <a>Pulse Repetition Frequency, \(PRF\) = <input type="number" id="radarPRF" value="1" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarPRFexp" onchange="ChangedRadar()">
            <option value="0">Hz</option>
            <option value="3" selected>kHz</option>
            <option value="6">MHz</option>
            <option value="9">GHz</option>
            <option value="12">THz</option>
        </select></a><br>
        <p id="radarrueqn">eqn</p>
        <a>The critical separation distance that quantifies a RADAR's ability to resolve two targets, Range Resolution, \(\Delta R\) depends upon the duration of the RADAR pulse,
            \(\tau\).</a><br>
        <a>Pulse Width, \(\tau\) = <input type="number" id="radarpw" value="100" onchange="ChangedRadar()" min="1" max="999">
        <select id="radarpwexp" onchange="ChangedRadar()">
            <option value="-12">ps</option>
            <option value="-9" selected>ns</option>
            <option value="-6">&#181;s</option>
            <option value="-3">ms</option>
            <option value="0">s</option>
        </select></a><br>
        <p id="radarresolutioneqn">eqn</p>
        <a>A RADAR Warning Receiver (RWR) is a radio receiver tuned to the RADAR's frequency, and can normally detect the RADAR system if enough power reaches the RWR antenna.
            This is a one-way path that is evaluated with the Friis equation, where \(G_T\) is the RADAR antenna gain, and \(G_R\) is the RWR receiver gain.
            Normally, we'll compute a maximum range for the sake of comparison with other range-based metrics. To avoid confusion with other values of \(R_{Max}\),
            we'll name this value \(R_{RWR}\).
        </a><br>
        <a>RWR Gain, \(G_R\) = </a><input type="number" id="rwrgain" value="1.64" onchange="ChangedRadar()" min="1" max="999999"><br>
        <a>RWR Minimum Receive Power, \(P_{Rmin}\) = </a>
        <input type="number" id="rwrprmin" value="1" onchange="ChangedRadar()" min="1" max="999">
            <select id="rwrprminexp" onchange="ChangedRadar()">
            <option value="-18">aW</option>
            <option value="-15">fW</option>
            <option value="-12">pW</option>
            <option value="-9">nW</option>
            <option value="-6" selected>&#181;W</option>
            <option value="-3">mW</option>
            <option value="0" >W</option>
        </select>
        <p id="radarrwreqn">eqn</p>
        <a>Both propagations, 2-way and 1-way, are limited to line-of-sight, so we'll compute \(R_{LOS}\).</a><br>
        <a>RADAR height above ground: </a>
        <input type="number" id="radarheight" value="10" min="0" max="50000" value="1000" onchange="ChangedRadar()">
        <a> ft. Target height above ground: </a>
        <input type="number" id="targetheight" value="10000" min="0" max="50000" value="1000" onchange="ChangedRadar()"><a> ft.</a>
        <p id="radarloseqn">eqn</p>
        <a>In determining "Who sees whom first?" the choice is somewhat involved. You may draw a picture or use the following concept: that we are finding
            which propagation case is less-limited. Separately, we'll check the final RADAR detection range against R<sub>U</sub> for ambiguous returns.
        </a>
        <p>\[ Max\begin{cases} Radar= & Min(R_{LOS},R_{Radar}) \\ RWR= & Min(R_{LOS},R_{RWR}) \end{cases}  \]</p>
        <p id="minmaxmessage">Min-Max</p>
        <a id="winnermessage">**</a>
        </a>
    </div>

    <!--DOPPLER TAB-->

    <div id="radardoppler" class="tabcontent">
        <hr />
        <p>The computations for \(R_{MAX}\) only help to determine whether a RADAR could detect a target.
            Actual range-finding is done by using the pulse's round-trip travel time and its known speed, \(c\).</p>
            <a>2-way travel time: \(t\) = <input type="number" id="radartime" value="1" onchange="ChangedDoppler()" min="1" max="999">
                <select id="radartimeexp" onchange="ChangedDoppler()">
                    <option value="-12">ps</option>
                    <option value="-9">ns</option>
                    <option value="-6">&#181;s</option>
                    <option value="-3" selected>ms</option>
                    <option value="0">s</option>
                </select></a><br>
        <p id="radartimedistanceeqn">eqn</p>
        <p>Of course, if you are measuring the time from just transmitter to receiver, do not divide by 2.</p>
            <a>1-way travel time: \(t\) = <input type="number" id="radiotime" value="1" onchange="ChangedDoppler()" min="1" max="999">
                <select id="radiotimeexp" onchange="ChangedDoppler()">
                    <option value="-12">ps</option>
                    <option value="-9">ns</option>
                    <option value="-6">&#181;s</option>
                    <option value="-3" selected>ms</option>
                    <option value="0">s</option>
                </select></a><br>
        <p id="radiotimedistanceeqn">eqn</p>
        <p>The Doppler effect is used to find a target's velocity. When the target is moving towards a RADAR, velocity
            is positive and the return frequency increases. When the target is moving away from a RADAR, return frequency will
            decrease. The sign can be entered as a negative velocity, by placing a '-' in place of \(\pm\)), or using a value of \(\theta\)
            that makes \(cos(\theta)\) negative. Choose one method.
        </p>
        <a>Frequency (original), \(f_0\) = <input type="number" id="radarFzero" value="2" onchange="ChangedDoppler()" min="1" max="999">
            <select id="radarFzeroexp" onchange="ChangedDoppler()">
                <option value="0">Hz</option>
                <option value="3">kHz</option>
                <option value="6">MHz</option>
                <option value="9" selected>GHz</option>
                <option value="12">THz</option>
            </select></a><br>
        <a>velocity, \(v\) = <input type="number" id="radarvelocity" value="100" onchange="ChangedDoppler()" min="1" max="999999"></a>\(m/s\)<br>
        <a>angle, \(\theta\) = <input type="number" id="radarangle" value="0" onchange="ChangedDoppler()" min="0" max="360"></a>&#176;<br>
        <a>To/From \(\pm\)</a><select id="radartowards" onchange="ChangedDoppler()">
        <option value="1" selected>Towards '+'</option>
        <option value="-1">Away   '-'</option></select>
        <p id="radarreturnfrequency">eqn</p>
        <p id="radarreturnshift">eqn</p>
        <a>In practice, a RADAR system will be used to compute velocity from the Doppler shift:</a><br>
        <a>Doppler Shift, \(\Delta f\) = <input type="number" id="radarShift" value="1.333" onchange="ChangedDoppler()" min="1" max="999">
            <select id="radarShiftexp" onchange="ChangedDoppler()">
                <option value="-3">mHz</option>
                <option value="0">Hz</option>
                <option value="3" selected>kHz</option>
                <option value="6">MHz</option>
                <option value="9">GHz</option>
                <option value="12">THz</option>
            </select></a><br>
        <p id="radarcomputevelocity">eqntocomputevelocity</p>
        <p>These Doppler equations disregard relativity and will be increasingly inaccurate at very high velocities.
        </p>
    </div>

    <!--JAMMING TAB-->

    <div id="radarjamming" class="tabcontent">
        <hr />
        COMING SOON!
    </div>

    <button id="nextsectionbutton" onclick="NextSection()">Next Section</button>
    <hr />
    Equation styling from <a href="https://www.mathjax.org">MathJax</a>
    <div style="font-size:10px;">
        Author: Thomas Kubler
    <a href="mailto:thomas.kubler@gmail.com">thomas.kubler@gmail.com</a>
    <a href="mailto:thomas.kubler@usafa.edu">thomas.kubler@usafa.edu</a>
</body>
</html>